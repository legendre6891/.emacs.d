#+TITLE: Emacs Configuration
#+AUTHOR: Kevin Li
#+DATE: August 23, 2015

* Prelude
This file is tangled and loaded via =init.el=, which
should just contain the following.
#+BEGIN_SRC emacs-lisp :tangle no
(require 'org)
(org-babel-load-file
 (expand-file-name
  "my-init.org"
  (concat user-emacs-directory "org"
   )))
#+END_SRC



* Package Setup
Most of the settings rely on installing packages. So the first
order of business is to initialize the package system.
#+BEGIN_SRC emacs-lisp
;; so we don't get bothered about coding system
(prefer-coding-system 'utf-8) 

(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives '("melpa" .
                                 "http://melpa.org/packages/"))
(package-initialize)
#+END_SRC
Next, we pull in the conveninence package =use-package=,
which is used to actually configure the packages
#+BEGIN_SRC emacs-lisp
;; Bootstrap `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)
#+END_SRC

I think the [[https://github.com/Malabarba/paradox][=paradox=]] package is a lot better than the built in one,
so let's install that.
#+BEGIN_SRC emacs-lisp
  (use-package paradox
      :ensure t)
#+END_SRC


* General Settings
These following settings should always be on, and depends
only on an up-to-date Emacs installation. They try to
provide a comfortable experience for debugging init files
in the case that the rest of the things somehow break.
** The Custom File
Don't litter =init.el= with customizations with =Customize=.
Create an empty file for it, in case it is not present.
Since emacs will refuse to load a completely empty file, we bootstrap
the custom file with a useless form [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Calling-Functions.html][=ignore=]].
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/emacs-custom.el")
  (if (not (file-exists-p custom-file))
      (write-region "(ignore \"Custom file loaded\")" nil custom-file))
    

  (load custom-file)
#+END_SRC

The =custom-file= is not kept under version control, so it is
convenient to put some personal settings in there that shouldn't be
seen on Github.  

The following function takes in a symbol and a
prompt; if the symbol isn't defined at this point (after the custom
file's loaded), then prompt the user for its value. Afterwards, put in the
custom file so it needn't be asked again.
#+BEGIN_SRC emacs-lisp :tangle yes
(defun ensure-in-custom (SYM PROMPT)
  (interactive)
  (if (not (boundp SYM))
      (let* ((entry (read-from-minibuffer PROMPT))
             (symbol (symbol-name SYM))
             (piece `(setq ,SYM ,entry)))
        (eval piece)
        (write-region (concat (prin1-to-string piece) "\n")
         nil custom-file 'append)
        )))
#+END_SRC
Now make sure that our full name and email address are always defined.
#+BEGIN_SRC emacs-lisp :tangle yes
(ensure-in-custom 'full-name "Enter your full name: ")
(ensure-in-custom 'email-address "Enter your email address: ")
#+END_SRC


** Home and Dropbox Folder setup
It is convenient to know where my "home" folder is (not the folder
that Emacs thinks is home), and also where the Dropbox folder
is. Later, we may define some shortcuts using these constants.
#+BEGIN_SRC emacs-lisp
  (setq user-home-folder
        (file-name-as-directory
         ;; Windows doesn't use the ~ convention
         (if (eq system-type 'windows-nt)
             (substitute-in-file-name "$HOMEDRIVE$HOMEPATH")
             "~")))

  (setq user-dropbox-folder
        (file-name-as-directory
         (concat user-home-folder "Dropbox")))
#+END_SRC


** Custom Elisp
*** Editing Related
Load some general use functions.
#+BEGIN_SRC emacs-lisp
  (use-package my-functions
    :load-path "lisp/")
#+END_SRC

*** Elisp Programming Related
A macro that makes a single form
into an anonymous function that calls the form
#+BEGIN_SRC emacs-lisp
  (defmacro ↑ (form)
      `(lambda () (interactive) ,form))
  (defmacro → (λ)
      `(lambda (x) (apply #',λ x)))
#+END_SRC


** General Settings
These settings should always be present.
*** Better Defaults
A no-frills package to set some sensible defaults.
#+BEGIN_SRC emacs-lisp
  (use-package better-defaults
      :ensure t)
#+END_SRC
*** Visuals
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq inhibit-startup-message t)
#+END_SRC

*** Tab Settings
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)
#+END_SRC

*** F-keys
Set =<f2>= and =<f3>= to =C-g= if the minibuffer is focused,
otherwise, execute an extended command =M-x=, for which
we use =smex=. 
#+BEGIN_SRC emacs-lisp
  (defun quit-or-smex ()
    (interactive)
    (if (window-minibuffer-p (frame-selected-window))
        (keyboard-escape-quit)
        (smex)))
  (global-set-key (kbd "<f3>") 'quit-or-smex)
  (global-set-key (kbd "<f4>") 'quit-or-smex)
#+END_SRC

Set =<f8>= to editing this very file.
#+BEGIN_SRC emacs-lisp
  (setq init-org-file
        (concat
         (file-name-as-directory (expand-file-name "org" user-emacs-directory))
         "my-init.org"))
  (global-set-key (kbd "<f8>") (↑ (find-file init-org-file)))
#+END_SRC

See [[Yasnippet]]; there, =<f1>= is also bound.

*** Popwin
Don't let temporary buffers annoy you! /Disabled because =popwin=
makes looking up functions when programming painful./
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package popwin
      :ensure t
      :config
      (popwin-mode 1))
#+END_SRC
*** Miscellaneous
Always show column numbers
#+BEGIN_SRC emacs-lisp
(column-number-mode t)
#+END_SRC

Never make me type =yes= or =no=.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Easier navigation with mark ring.
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

Don't garbage collect so much.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 1024 1024 50))
#+END_SRC


** Global Keybindings
*** F-keys
Set =<f2>= and =<f3>= to =C-g= if the minibuffer is focused,
otherwise, execute an extended command =M-x=, for which
we use =smex=. 
#+BEGIN_SRC emacs-lisp
  (defun quit-or-smex ()
    (interactive)
    (if (window-minibuffer-p (frame-selected-window))
        (keyboard-escape-quit)
        (smex)))
  (global-set-key (kbd "<f3>") 'quit-or-smex)
  (global-set-key (kbd "<f4>") 'quit-or-smex)
#+END_SRC

Set =<f8>= to editing this very file.
#+BEGIN_SRC emacs-lisp
  (setq init-org-file
        (concat
         (file-name-as-directory (expand-file-name "org" user-emacs-directory))
         "my-init.org"))
  (global-set-key (kbd "<f8>") (↑ (find-file init-org-file)))
#+END_SRC


Set =<f12>= to open the current buffer in Windows Explorer.
Taken from here.
#+BEGIN_SRC emacs-lisp
  (defun my-open-in-windows-explorer ()
    "Launch the windows explorer in the current directory and selects current file"
    (interactive)
    (w32-shell-execute
     "open"
     "explorer"
     (concat "/e,/select," (convert-standard-filename buffer-file-name))))

  (defun browse-file-directory ()
    "Open the current file's directory however the OS would."
    (interactive)
    (if default-directory
        (browse-url-of-file (expand-file-name default-directory))
      (error "No `default-directory' to open")))

  (if (eq system-type 'gnu/linux)
      (global-set-key [f12] #'browse-file-directory))

  (if (eq system-type 'windows-nt)
      (global-set-key [f12] 'my-open-in-windows-explorer))

#+END_SRC

**** TODO Support other operating systems.
     
*** Pause-key
See section on [[Restart Emacs]].

** Ido, Recentf, and Smex
*** General settings
Ido is one of the reasons why Emacs is great! It takes a little bit of
setting up to make it more comfortable to use.

Enable virtual buffers: even if a buffer is closed, we still have
access to it.
#+BEGIN_SRC emacs-lisp
(setq ido-use-virtual-buffers t)
#+END_SRC

When a filename doesn't complete, ido will search recently used
names. This is annoying, so disable it.
#+BEGIN_SRC emacs-lisp
(setq ido-auto-merge-work-directories-length -1)
#+END_SRC

=Flx Ido= uses another algorithm to calculate matches which seems to
work better than the default.
#+BEGIN_SRC emacs-lisp
(use-package flx-ido
    :ensure t
    :config (flx-ido-mode 1))
#+END_SRC

Make the completion interface vertical; it is more legible this way.
In addition, define up and down keys, because =<left>= and =<right>=
arrows are too inconvenient.
#+BEGIN_SRC emacs-lisp
(use-package ido-vertical-mode
    :ensure t
    :config
    (progn
      (ido-vertical-mode 1)
      (defun ido-define-keys () ;; C-n/p is more intuitive in vertical layout
        (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
        (define-key ido-completion-map (kbd "C-j") 'ido-next-match)
        (define-key ido-completion-map (kbd "C-k") 'ido-prev-match)
        (define-key ido-completion-map (kbd "C-p") 'ido-prev-match))
      (add-hook 'ido-setup-hook 'ido-define-keys)))
#+END_SRC

*** Ido everywhere
Use Ido for most completions; sadly this doesn't quite cover 100% of
the cases yet, but it's close.
#+BEGIN_SRC emacs-lisp
(ido-everywhere)
(use-package ido-ubiquitous
    :ensure t
    :init
    (progn
      (ido-ubiquitous-mode 1)
      (defmacro ido-ubiquitous-use-new-completing-read (cmd package)
        `(eval-after-load ,package
           '(defadvice ,cmd (around ido-ubiquitous-new activate)
             (let ((ido-ubiquitous-enable-compatibility nil))
               ad-do-it)))))
    :config
    (progn
      (ido-ubiquitous-use-new-completing-read yas/expand 'yasnippet)
      (ido-ubiquitous-use-new-completing-read yas/visit-snippet-file 'yasnippet)))
#+END_SRC
The last two lines are used to make make completing with =yasnippet=
work well.

**** TODO Investigate Helm?

*** Recentf
Recentf supports Ido mode by keeping track of recently organized files.
#+BEGIN_SRC emacs-lisp
(use-package recentf
    :config
  (progn
    (recentf-mode 1)
    (setq recentf-max-menu-items 500)))
#+END_SRC

*** Smex
=M-x= support but for ido.
#+BEGIN_SRC emacs-lisp
(use-package smex
    :ensure t
    :bind
    (("M-x" . smex)
     ("C-x C-m" . smex)
     ("C-c C-m" . smex)
     ("C-c m" . smex)
     ("C-x m" . smex)))
#+END_SRC



** Helm

*** Installation
Can't believe I'm using =helm= now; it's a great program in
moderation. But it's a good package and there's no reason
to ignore it.
#+BEGIN_SRC emacs-lisp
  (use-package helm
      :ensure t
      :init
      (progn
        (require 'helm-config)))
#+END_SRC

*** Key bindings
I like =helm-kill-ring= and =helm-mark-ring= and =helm-mini=.
For the kill-ring, use the bind =M-y=, but to preserve
default behavior, only activate it when we didn't just use 
=C-y=.
#+BEGIN_SRC emacs-lisp
  (defun my-show-kill-ring ()
    (interactive)
    (if (not (eq last-command 'yank))
        (helm-show-kill-ring)
        (progn
          (setq this-command 'yank)
          (call-interactively 'yank-pop))))

  (global-set-key (kbd "M-y") 'my-show-kill-ring)

  (global-set-key (kbd "C-h SPC") 'helm-mark-ring)
  (global-set-key (kbd "C-h C-SPC") 'helm-mark-ring)

  (global-set-key (kbd "C-x b") 'helm-mini)
  (setq helm-buffers-fuzzy-matching t)
  (setq helm-recentf-fuzzy-match t)
#+END_SRC


** Mac OS X specific settings
We need let Emacs know about the the =LaTeX= path
for =LaTeX= to work.
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (progn
        (defun set-exec-path-from-shell-PATH ()
          (let ((path-from-shell
                 (shell-command-to-string
                  "TERM=vt100 $SHELL -i -c 'echo $PATH'")))

            (setenv "PATH" path-from-shell)
            (setq exec-path (split-string path-from-shell path-separator))))

        (when window-system (set-exec-path-from-shell-PATH))

        (getenv "PATH")
        (setenv "PATH" (concat "/usr/texbin" ":" (getenv "PATH")))

        (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
        (setq exec-path (append exec-path '("/usr/local/bin")))

        (setenv "PATH" (concat (getenv "PATH") ":/usr/bin"))
        (setq exec-path (append exec-path '("/usr/bin")))))
#+END_SRC


** Hydra
Hydra mode is a new package that allow one to create custom interfaces
like Org's export menu. It is great for mapping commands that one
would like a hotkey for but isn't used enough to use an entire
keybinding.
#+BEGIN_SRC emacs-lisp
  (use-package hydra
      :ensure t)
#+END_SRC

*** Yasnippet Hydra
See [[Yasnippet]].

*** GUI Hydra
I want a hydra to control various
GUI elements (e.g. linum-mode, theme, font).

#+BEGIN_SRC emacs-lisp
  (defhydra my-hydra-gui (:color blue)
    ("l" global-nlinum-mode "Toggle line numbers.")
    ("f" menu-set-font "Set font.")
    ("m" menu-bar-mode "Toggle menu bar.")
    ("t" (load-theme 'ample-flat) "Load theme")
    ("d" (disable-theme 'ample-flat) "Disable theme")
    )

  (global-set-key (kbd "<f2>") #'my-hydra-gui/body)
#+END_SRC


** Restart Emacs
It's nice to have a shortcut to restart emacs on.
#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
      :ensure t
      :init
      (global-set-key (kbd "<pause>") #'restart-emacs))
#+END_SRC


* Look and Feel
Here, we install various themes.  Install =emacs24= themes and set up
a font. I'm not sure at this point whether to simply /install/ the
themes or actually activate them.
** Themes
Install but defer.
#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-tomorrow
    :defer t
    :ensure t)
(use-package ample-theme
    :defer t
    :ensure t)
(use-package smyx-theme
    :defer t
    :ensure t)
(use-package aurora-theme
    :defer t
    :ensure t)
#+END_SRC
*** Activate theme
The =aurora-theme= is the current favorite.
The extra =t= flag is so we don't get asked about treating themes
as safe. For now, don't active because keeping the default theme is best.
#+BEGIN_SRC emacs-lisp
(load-theme 'ample-flat t)
#+END_SRC


** Fonts
*** Activating a font
#+BEGIN_SRC emacs-lisp
  (defun my-set-face (font height)
    (set-face-attribute 'default nil
                        :family font
                        :height (* height 10)
                        :weight 'normal
                        :width 'normal))

  (if (eq system-type 'darwin)
      (my-set-face "Menlo" 14))

  (if (eq system-type 'windows-nt)
      (my-set-face "Consolas" 12))

  (if (eq system-type 'gnu/linux)
      (my-set-face "PragmataPro" 12))

    
#+END_SRC

*** TODO cycle between fonts
Write a function (a la Spacemacs) that allows me to switch between fonts.
**** With ido support?

*** TODO Check whether the font exists


** Frame size and position
Make the initial frame always size 80 by 40.
#+BEGIN_SRC emacs-lisp
(when window-system (set-frame-size (selected-frame) 80 40))
#+END_SRC


** Smart Mode Line
I'm actually not convined of the utility of this just yet,
but let's throw it in because it does look somewhat nicer than the
default mode line.
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
    :ensure smart-mode-line
    :init
    (progn
      (setq sml/theme 'light)
      (setq sml/name-width 40)
      (setq sml/mode-width 'full))
    :config
    (progn
      (sml/setup)))
#+END_SRC

*** TODO Investigate this more and make it more functional


** Line Numbers
Line numbers are surprisingly clunky in Emacs, which above all
is a text editor. The =nlinum= package seems to be the best, and I
find it useful enough to enable it everywhere.
#+BEGIN_SRC emacs-lisp
(use-package nlinum
    :ensure t
    :init
    (global-nlinum-mode t))
#+END_SRC




* Expand Region and Avy Mode
Expand region is occasionally useful for editing Lisp and I suppose
sometimes for LaTeX if I set it up correctly. The =M-SPC= shortcut
usually doesn't work (on Windows/Linux), but thankfully I know how
disable it in Linux. 
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
      :ensure t
      :bind
      (("C-=" . er/expand-region)))
#+END_SRC
** TODO Windows Alt Space shortcut


Avy mode helps is a quicker way to move around; they work like Vim's
=f=, =F=, =t=, =T= operators.
#+BEGIN_SRC emacs-lisp
  (use-package avy
      :ensure t
      :bind
      (("C-'" . avy-goto-char-2)))
#+END_SRC




* Evil Mode
After several iterations of
switching back and forth from Emacs and Vim, I gave Evil a go.
It worked great for a while, but in the end it was just more hassle
than it's worth, the reason being that key-binds in Emacs
and its many modes are not designed with modal input in mind.

Thus, it became a hassle to define new keys,
especially when I wanted to enable keys only for
insert mode only for certain key-maps. I can't find a good solution
for this, so I turned off =evil-mode= for the time being.

But my old =evil-mode= customizations are still useful
if I ever wanted to come back to it, so I include them here.
** TODO Include evil mode stuff
I need to figure out a way to reference (and attach?) files
to an org document.


* Yasnippet
** Introduction
Yasnippet is generally useful, except that it takes over
the =TAB= key, which performs crucial functions in Org mode and
CDLaTeX.

It seems that =C-;= is unused in both modes, so we will just map the
key to that.
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
      :ensure t
      :init
      (progn
        (setq yas-snippet-dirs
              (list (concat user-emacs-directory
                            (file-name-as-directory "snippets")))))
      :config
      (progn
        (yas-global-mode)
        (define-key yas-minor-mode-map (kbd "<tab>") nil)
        (define-key yas-minor-mode-map (kbd "TAB") nil)
        (define-key yas-minor-mode-map (kbd "C-;") 'yas-expand)
        (define-key yas-keymap (kbd "C-j") 'yas-prev-field)
        (define-key yas-keymap (kbd "C-;") 'yas-next-field-or-maybe-expand)
        ))
#+END_SRC

Use ido prompting method.
#+BEGIN_SRC emacs-lisp
  (setq yas-prompt-functions '(yas-ido-prompt yas-completing-prompt))
#+END_SRC



** Yasnippet Hydra
I believe that =yasnippet= is hugely good, but it takes some time to
configure that the process is just slightly "too painful" that I avoid
using it. Let's settle this with a neat =hydra= /globally/ bound to the ever so
easy to reach =f1=.
#+BEGIN_SRC emacs-lisp  
  (defhydra hydra-yasnippet (:color blue :hint nil)
      "
                  ^YASnippets^
    --------------------------------------------
      Modes:    Load/Visit:    Actions:

     _g_lobal  _d_irectory    _i_nsert
     _m_inor   _f_ile         _t_ryout
     _e_xtra   _l_ist         _n_ew
             _a_ll            _v_isit
    "
      ("d" yas-load-directory)
      ("e" yas-activate-extra-mode)
      ("i" yas-insert-snippet)
      ("f" yas-visit-snippet-file :color blue)
      ("n" yas-new-snippet)
      ("t" yas-tryout-snippet)
      ("l" yas-describe-tables)
      ("g" yas/global-mode)
      ("m" yas/minor-mode)
      ("a" yas-reload-all)
      ("v" yas-visit-snippet-file))

  (global-set-key (kbd "<f1>") 'hydra-yasnippet/body)
#+END_SRC

While in snippet mode, saving a snippet should just load and quit.
#+BEGIN_SRC emacs-lisp
  (define-key snippet-mode-map (kbd "C-x C-s")
    #'yas-load-snippet-buffer-and-close)
#+END_SRC


** TODO Add different folders for different modes of snippet files

** TODO Add a shortcut for visiting snippet

** TODO Add a shortcut for creating a snippet.
   

* Smartparens
=Smartparens= is almost a necessity in C-like languages; it is less
essentially useless in Lisps because we will be using =paredit=. Also,
smartparens is kind of useful in (La)TeX mode, so we should turn it on
there in addition to Org mode.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
  :ensure t
      :init
    (smartparens-global-mode 1)
    (show-smartparens-global-mode 1)
    :bind
    (("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp))
    :config
    (progn
      (use-package smartparens-config)
      (add-hook 'emacs-lisp-mode-hook 'turn-off-smartparens-mode)
    ))
#+END_SRC


* Paredit

Enable =paredit=; I still prefer it over =smartparens= because it
actually comes with a good set of keybindings, and old habits die
hard.
#+BEGIN_SRC emacs-lisp
  (use-package paredit
      :ensure t
      :config
      (progn
        (add-hook 'emacs-lisp-mode-hook       'enable-paredit-mode)
        (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
        (add-hook 'ielm-mode-hook             'enable-paredit-mode)
        (add-hook 'lisp-mode-hook             'enable-paredit-mode)
        (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
        (add-hook 'scheme-mode-hook           'enable-paredit-mode)))
#+END_SRC



* Org Mode
** Appearance
Since we use Org Babel so often, it is important to highlight
code in source blocks.
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Fontify the whole heading to make it look nice.
#+BEGIN_SRC emacs-lisp
  (setq org-fontify-whole-heading-line t)
#+END_SRC


** Editing features
We can also allow plain lists starting with alphabet instead
of just numbers.
#+BEGIN_SRC emacs-lisp
  (setq org-list-allow-alphabetical t)
#+END_SRC

Let's be smart about invisible edits.
#+BEGIN_SRC emacs-lisp
  (setq org-catch-invisible-edits 'show-and-error)
#+END_SRC

We always want to turn on =auto-fill-mode= in Org files, so that lines
automagically wrap at 80 columns.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'auto-fill-mode)
#+END_SRC


** Directory structure
Set the *default directory* for Org-mode.
#+BEGIN_SRC emacs-lisp
  (let ((org-folder
         (file-name-as-directory (concat user-dropbox-folder "ORG"))))
    (setq org-directory org-folder))
#+END_SRC


** Custom key binds
Set the global hotkeys which are commended in the manual.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c b") 'org-iswitchb)
#+END_SRC
  
We need an easier key on LaTeX. In future Org versions, use
=org-toggle-latex-fragment=.
#+BEGIN_SRC emacs-lisp
  (org-defkey org-mode-map (kbd "C-.") 'org-preview-latex-fragment)
#+END_SRC


** Support for LaTeX in Org
*** Inside Org Mode
Larger LaTeX fonts; it seems that 1.4 is too large, so let's leave this
*OFF* for now.
#+BEGIN_SRC emacs-lisp :tangle no
  (plist-put org-format-latex-options :scale 1.4)
  (plist-put org-format-latex-options :html-scale 1.4)
#+END_SRC

Autoload CDLaTeX mode and RefTeX.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
  (add-hook 'org-mode-hook (↑ (reftex-mode t)))
#+END_SRC

Turn on LaTeX syntax highlighting.
#+BEGIN_SRC emacs-lisp
  (setq org-highlight-latex-and-related '(latex script))
#+END_SRC

**** TODO Make the dollar sign $ type actual dollars.

*** Exporting to LaTeX
**** Margins and Microtype
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("final" "microtype"))
  (add-to-list 'org-latex-packages-alist '("margin=1in" "geometry"))
#+END_SRC
**** TODO Theorems



**** Colors in exported code blocks.
Perhaps =minted= is the better choice, but there are apparently "repercussions"
that I don't want to deal with, as outlined in the documentation
of =org-latex-listings=.
#+BEGIN_SRC emacs-lisp
  (setq org-latex-listings 'minted)
  (require 'ox-latex)
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
      "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
      "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
      ))
#+END_SRC

**** TODO Insert the appropriate packages
     - geometry
     - enumitem
     - mathtools
     - microtype?
**** TODO choose a set of fonts?
**** TODO Need to configure how the title looks


** HTML Export settings
Highlight code blocks in HTML.
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
      :ensure t)
#+END_SRC


The footer is somewhat useless; don't show it at all.
#+BEGIN_SRC emacs-lisp
  (setq org-html-validation-link nil)
#+END_SRC

Turn off TOC and and headline numbering in HTML.
#+BEGIN_SRC emacs-lisp
  (defun my-org-change-html-options (plist backend)
    (when (eq backend 'html)
      (plist-put plist :with-toc nil)
      (plist-put plist :section-numbers nil)
      ))

  (add-to-list 'org-export-filter-options-functions #'my-org-change-html-options)
#+END_SRC

We want to use the [[https://cmcenroe.me/writ/][Writ CSS]] style, so we need to wrap everything
around an article tag.
#+BEGIN_SRC emacs-lisp
  (setq org-html-divs
        '((preamble "div" "preamble")
          (content "article" "")
          (postamble "div" "postamble")))
#+END_SRC


** Easy templates
Since =emacs-lisp= code blocks are so prevalent,
make a new template key for them, using =E=.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC


* Emacs-Lisp
Use CL lisp indent; it seems preferable in these =use-package=
macros.
#+BEGIN_SRC emacs-lisp
  (setq lisp-indent-function 'common-lisp-indent-function)
#+END_SRC

See the section [[Paredit]] that turns on =paredit-mode=
for elisp files.


* LaTeX
Emacs is the best text editor for editing plain TeX and LaTeX files; I
am slowly in the process of migrating from TeX/LaTeX to Org, but that
process will require sometime as RefTeX does not yet work gracefully
with LaTeX. Without further ado ...

** AucTeX
AucTeX is an improved mode for editing LaTeX files; we will not use
most of its features since the minor mode CDLaTeX subsumes some
of them.

*** Installation
First make sure that =auctex= is installed
#+BEGIN_SRC emacs-lisp
  (use-package tex-site
      :ensure auctex)
#+END_SRC

*** Parsing
Enable parse on load and save (useful for detecting plain TeX
versus LaTeX).
#+BEGIN_SRC emacs-lisp
(setq TeX-parse-self t)
(setq TeX-auto-save t)
#+END_SRC

*** Producing DVI vs PDF
We can configure AucTeX to automatically produce PDFs, but
I actually prefer DVI files, so let's leave the following setting
off for now.
#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC

*** Arara
Arara is a snazzy tool! See
[[http://emacs.stackexchange.com/questions/9715/arara-integration-in-emacs][this Emacs.SE answer]] for how to set it up.
#+BEGIN_SRC emacs-lisp
(eval-after-load "tex"
  '(add-to-list 'TeX-command-list
        '("Arara" "arara %s" TeX-run-TeX nil t :help "Run Arara.")))
#+END_SRC

*** Viewers 
For Mac OS, =Skim= is the best PDF viewer (even though it is not that
good). For Windows, it is clearly SumatraPDF. On Linux, evince and
xdvi are quite good. I stole the code below from somewhere (on
TeX.SX). It works, and I don't want to mess with it.
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (setq
       ;; Set the list of viewers for Mac OS X.
       TeX-view-program-list
       '(("Preview.app" "open -a Preview.app %o")
         ("Skim" "open -a Skim.app %o")
         ("displayline" "displayline %n %o %b")
         ("open" "open %o"))
       ;; Select the viewers for each file type.
       TeX-view-program-selection
       '((output-dvi "open")
         (output-pdf "Skim")
         (output-html "open"))))

  (if (eq system-type 'windows-nt)
      (progn 
        (setq TeX-output-view-style
              '("^pdf$" "." "SumatraPDF.exe -reuse-instance %o"))
        (setq TeX-view-program-list
              '(("SumatraPDF" "SumatraPDF.exe -reuse-instance %o")))
        (setq TeX-view-program-selection '((output-pdf "SumatraPDF")
                                           (output-dvi "Yap")))))

  (when (eq system-type 'gnu/linux)
    (setq TeX-view-program-list '(("MUPDF" "mupdf -r 153 %o")
                                  ("ZATHURA" zathura-forward-search)
                                  ("LLPP" "llpp %o")
                                  ("XDVI" "xdvi %o")))
    (setq TeX-view-program-selection '((output-pdf "ZATHURA")
                                       (output-pdf "Evince")
                                       (output-dvi "xdvi"))))


  ;; See http://tex.stackexchange.com/questions/207889/how-to-set-up-forward-inverse-searches-with-auctex-and-zathura
  (setq zathura-procs ())
  (defun zathura-forward-search ()
    ;; Open the compiled pdf in Zathura with synctex. This is complicated since
    ;; 1) Zathura refuses to acknowledge Synctex directive if the pdf is not
    ;; already opened
    ;; 2) This means we have to bookkeep open Zathura processes ourselves: first
    ;; open a new pdf from the beginning, if it is not already open. Then call
    ;; Zathura again with the synctex directive.
    (interactive)
    (let* ((zathura-launch-buf (get-buffer-create "*Zathura Output*"))
           (pdfname (TeX-master-file "pdf"))
           (zatentry (assoc pdfname zathura-procs))
           (zatproc (if (and zatentry (process-live-p (cdr zatentry)))
                        (cdr zatentry)
                      (progn
                        (let ((proc (progn (message "Launching Zathura")
                                           (start-process "zathura-launch"
                                                          zathura-launch-buf "zathura"
                                                           "-x" "emacsclient +%{line} %{input}" pdfname))))
                          (when zatentry
                            (setq zathura-procs (delq zatentry zathura-procs)))
                          (add-to-list 'zathura-procs (cons pdfname proc))
                          (set-process-query-on-exit-flag proc nil)
                          proc))))
           (pid (process-id zatproc))
           (synctex (format "%s:0:%s"
                            (TeX-current-line)
                            (TeX-current-file-name-master-relative)))
           )
      (start-process "zathura-synctex" zathura-launch-buf "zathura" "--synctex-forward" synctex pdfname)
      (start-process "raise-zathura-wmctrl" zathura-launch-buf "wmctrl" "-a" pdfname)
      ))
#+END_SRC

*** Minor modes for editing LaTeX
Hard-wrap and disable =electric-indent-mode= which messes
up AucTeX's internal indentation code. This actually depends
on AucTeX since it defines =LaTeX-mode-hook=.
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
  (add-hook 'LaTeX-mode-hook (↑ (electric-indent-mode -1)))
  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
#+END_SRC


** RefTeX
*** Installation
#+BEGIN_SRC emacs-lisp
  (use-package reftex ; TeX/BibTeX cross-reference management
      :defer t
      :init
      (progn
        (add-hook 'LaTeX-mode-hook #'reftex-mode)
        (setq reftex-plug-into-AuCTeX t)))

(setq reftex-label-alist nil)
#+END_SRC


** CDLaTeX
CDLaTeX is the last piece of the triumphrate of
LaTeX facilities for LaTeX.

*** Installation
#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
      :ensure t)
#+END_SRC

Now we can always turn it on, both for LaTeX and for TeX.
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook 'turn-on-cdlatex)
  (add-hook 'LaTeX-mode-hook 'turn-on-cdlatex)
#+END_SRC

*** 

*** Automatic Parentheses
Thankfully, [[Smartparens][=smartparens=]] can be ued in LaTeX mode no problem;
therefore, we don't need to have CDLaTeX do the work
#+BEGIN_SRC emacs-lisp
  (setq cdlatex-paired-parens "")
  (define-key cdlatex-mode-map "$" nil)
  (define-key cdlatex-mode-map "(" nil)
  (define-key cdlatex-mode-map "{" nil)
  (define-key cdlatex-mode-map "[" nil)
  (define-key cdlatex-mode-map "|" nil)
  (define-key cdlatex-mode-map "<" nil)
#+END_SRC


*** Templates
Pressing =<tab>= in CDLaTeX, among other things, active a poor man's
version of =yasnippet=. It is preferable to =yasnippet= because it
integrates better with the rest of CDLaTeX.

**** Math Shortcuts


#+BEGIN_SRC emacs-lisp
  (defun simple-math-template (key docstring expansion)
    `(,key ,docstring ,expansion cdlatex-position-cursor nil nil t))

  (setq my-math-templates 
        (mapcar (→ simple-math-template)
                '(
                  ("bi" "Insert \\binom{}{}" "\\binom{?}{}")
                  ("ggr(" "Insert \biggl( \biggr)" "\\biggl(? \\biggr")
                  ("ggr|" "Insert \biggl| \biggr|" "\\biggl|? \\biggr|")
                  ("ggr{" "Insert \biggl\{ \biggr\}" "\\biggl\\{? \\biggr\\")
                  ("ggr[" "Insert \biggl[ \biggr]" "\\biggl[? \\biggr")
                  ("ce" "Insert ceilings" "\\lceil? \\rceil")
                  ("fl" "Insert floors" "\\lfloor? \\rfloor")
                  ("ggrce" "Insert ceilings" "\\biggl\\lceil? \\biggr\\rceil")
                  ("ggrfl" "Insert floor" "\\biggl\\lfloor? \\biggr\\rfloor")
                  ("int" "Insert integrals without limits" "\\int_{?}^{}")
                  ("sum" "Insert sums without limits" "\\sum_{?}^{}")
                  ("prod" "Insert products without limits" "\\prod_{?}^{}")
                  ("prodl" "Insert products" "\\prod\\limits_{?}^{}"))))

  (setq cdlatex-command-alist my-math-templates)

  (setq cdlatex-math-modify-alist
        '((?t "\\text" nil t nil nil)
          (?s "\\mathscr" nil t nil nil)
          ))
#+END_SRC

Custom symbols.
#+BEGIN_SRC emacs-lisp
  (defmacro my-define-keys
      (mode-map kbd greek-letter)
    `(define-key ,mode-map (kbd ,kbd) (↑ (insert ,greek-letter))))


  (with-eval-after-load 'latex
    (define-key LaTeX-mode-map (kbd "s-b") (↑ (insert "\\beta")))
    (my-define-keys LaTeX-mode-map "C-o" "\\circ")
    )
#+END_SRC


**** Environment support
To support inserting environments, we need to setup both AucTeX,
RefTeX, and CDLaTeX in tandem. For example, to setup the axiom
environment, we need to do the following (this code block is not
tangled)
#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list
   'reftex-label-alist
   '("axiom" ?a "ax:" "~\\ref{%s}" t ("axiom" "ax.")))

  (LaTeX-add-environments
   '("axiom" LaTeX-env-label))

  (add-to-list
   'cdlatex-command-alist
   '("axm" "Insert axiom env" "" cdlatex-environment ("axiom") t nil))

  (add-to-list
   'cdlatex-env-alist
   '("axiom" "\\begin{axiom}\nAUTOLABEL\n?\n\\end{axiom}\n" nil))
#+END_SRC

Now add the environments.
#+BEGIN_SRC emacs-lisp
  (defun my-setup-latex-environment (env ref-char ref-key shortcut doc)
    (add-to-list 'reftex-label-alist
                 (list env
                       ref-char
                       (concat ref-key ":")
                       "~\\ref{%s}"
                       t
                       `(,env ,(concat (substring env 0 2) "."))))

    (LaTeX-add-environments
     `(,env LaTeX-env-label))

    (add-to-list 'cdlatex-command-alist
                 `(,shortcut ,doc "" cdlatex-environment ,(list env) t nil))

    (add-to-list 'cdlatex-env-alist
                 (list env
                       (format "\\begin{%s}\nAUTOLABEL\n?\n\\end{%s}" env env)
                       nil))
    )

  (with-eval-after-load "latex"
    (mapcar (→ my-setup-latex-environment)
            '(("axiom" ?a "ax" "axm" "Insert an axiom.")
              ("theorem" ?t "thr" "thr" "Insert a theorem.")
              ("lemma" ?l "lem" "lem" "Insert a lemma.")
              ("claim" ?c "clm" "clm" "Insert a claim.")
              ("proposition" ?p "prop" "prop" "Insert a proposition.")
              ("wts" ?w "ax" "wts" "Insert a 'want to show'.")
              ("definition" ?d "def" "def" "Insert a definition."))))

  (add-to-list 'cdlatex-command-alist
               '("pr" "Insert proof env" "" LaTeX-environment-menu ("proof") t nil))
#+END_SRC



** Shortcuts
*** Compiling
Compiling shouldn't have to be =C-c C-c <RET>=, and viewing
shouldn't have to be =C-c C-v=. Rebind these keys to hotkeys that are
normally of no use anyway.
#+BEGIN_SRC emacs-lisp
  (defun latex-compile ()
    (interactive)
    (save-buffer)
    (TeX-command "LaTeX" 'TeX-master-file))

  (defun my-tex-compile ()
    (interactive)
    (save-buffer)
    (TeX-command "TeX" 'TeX-master-file))


  (eval-after-load 'latex
    '(define-key LaTeX-mode-map (kbd "C-t") 'latex-compile))

  (eval-after-load 'latex
    '(define-key LaTeX-mode-map (kbd "C-v") 'TeX-view))

  (eval-after-load 'plain-tex
    '(define-key plain-TeX-mode-map (kbd "C-t") 'my-tex-compile))

  (eval-after-load 'plain-tex
    '(define-key plain-TeX-mode-map (kbd "C-v") 'TeX-view))
#+END_SRC

*** Moving
I don't use the commands that move between environments often enough
to justify  entire keybindings, so disable them.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'latex
    (define-key LaTeX-mode-map (kbd "C-M-a") nil)
    (define-key LaTeX-mode-map (kbd "C-M-e") nil))
#+END_SRC

*** TODO Make M-u insert an underscore, M-i insert caret, and M-o insert both
Next define easy shortcuts for inserting underscores
and the like.


* Clojure


* Julia
** TODO Write some configurations --- broken at the moment
#+BEGIN_SRC emacs-lisp
  (use-package julia-mode
      :ensure t)

  (use-package julia-shell-mode
      :ensure julia-shell)

  (defun my-julia-mode-hooks ()
    (require 'julia-shell-mode))
  (add-hook 'julia-mode-hook 'my-julia-mode-hooks)
  (define-key julia-mode-map (kbd "C-c C-c") 'julia-shell-run-region-or-line)
  (define-key julia-mode-map (kbd "C-c C-s") 'julia-shell-save-and-go)
#+END_SRC


* J mode
I have a soft spot for the J programming language---guess it appeals
to my inner mathematician + hacker meld because it is so terse?
Anyhow, here is support for the J lang.
#+BEGIN_SRC emacs-lisp
  (use-package j-mode
      :ensure t
      :init
      (custom-set-faces
       '(j-verb-face ((t (:foreground "Red"))))
       '(j-adverb-face ((t (:foreground "DarkGreen"))))
       '(j-conjunction-face ((t (:foreground "Blue"))))
       '(j-other-face ((t (:foreground "Black")))))
      )
#+END_SRC

* Undo Tree
Undo tree gives a nice visualization of the undo-state. It makes
navigating the undo states much more intuitive.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
      :ensure t
      :config
      (progn
        (global-undo-tree-mode)
        (with-eval-after-load 'undo-tree
          (define-key undo-tree-visualizer-mode-map (kbd "M-u") #'undo-tree-visualizer-quit)
          (define-key undo-tree-visualizer-mode-map (kbd "j") #'undo-tree-visualize-redo)
          (define-key undo-tree-visualizer-mode-map (kbd "k") #'undo-tree-visualize-undo)
          (define-key undo-tree-visualizer-mode-map (kbd "h") #'undo-tree-visualize-switch-branch-left)
          (define-key undo-tree-visualizer-mode-map (kbd "l") #'undo-tree-visualize-switch-branch-right)
          )
        )
      :bind
      ("M-u" . undo-tree-visualize))
#+END_SRC


* Epilog
Packages to investigate
- [[https://github.com/mrkkrp/zzz-to-char][=zzz-char=]]




Some Org mode related settings to to faciliate editting of this file.

#+PROPERTY: header-args:emacs-lisp :tangle yes

#+LATEX_HEADER: \usepackage{tgtermes}
#+LATEX_HEADER: \usepackage{inconsolata}

