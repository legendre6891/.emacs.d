#+TITLE: Emacs Configuration
#+AUTHOR: Kevin Li
#+DATE: February 22, 2017
#+BEGIN_SRC emacs-lisp
  (defvar ido-cur-list nil)
#+END_SRC
* Prelude
  This file is tangled and loaded via =init.el=, which
  should just contain the following.
  #+BEGIN_SRC emacs-lisp :tangle no
    (require 'org)
    (org-babel-load-file
     (expand-file-name
      "my-init.org"
      (concat user-emacs-directory "org")))
  #+END_SRC



* Package Setup
  Most of the settings rely on installing packages. So the first
  order of business is to initialize the package system.
  #+BEGIN_SRC emacs-lisp
;; so we don't get bothered about coding system
(prefer-coding-system 'utf-8) 

(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives '("melpa" .
                                 "http://melpa.org/packages/"))
(package-initialize)
  #+END_SRC
  Next, we pull in the conveninence package =use-package=,
  which is used to actually configure the packages
  #+BEGIN_SRC emacs-lisp
;; Bootstrap `use-package'
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)
  #+END_SRC

  I think the [[https://github.com/Malabarba/paradox][=paradox=]] package is a lot better than the built in one,
  so let's install that.
  #+BEGIN_SRC emacs-lisp
  (use-package paradox
      :ensure t)
  #+END_SRC

  
* General Settings
  These following settings should always be on, and depends
  only on an up-to-date Emacs installation. They try to
  provide a comfortable experience for debugging init files
  in the case that the rest of the things somehow break.
** The Custom File
   Don't litter =init.el= with customizations with =Customize=.
   Create an empty file for it, in case it is not present.
   Since emacs will refuse to load a completely empty file, we bootstrap
   the custom file with a useless form [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Calling-Functions.html][=ignore=]].
   #+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/emacs-custom.el")
  (if (not (file-exists-p custom-file))
      (write-region "(ignore \"Custom file loaded\")" nil custom-file))

  (load custom-file)
   #+END_SRC

   The =custom-file= is not kept under version control, so it is
   convenient to put some personal settings in there that shouldn't be
   seen on Github.  

   The following function takes in a symbol and a
   prompt; if the symbol isn't defined at this point (after the custom
   file's loaded), then prompt the user for its value. Afterwards, put in the
   custom file so it needn't be asked again.
   #+BEGIN_SRC emacs-lisp
(defun ensure-in-custom (SYM PROMPT)
  (interactive)
  (if (not (boundp SYM))
      (let* ((entry (read-from-minibuffer PROMPT))
             (symbol (symbol-name SYM))
             (piece `(setq ,SYM ,entry)))
        (eval piece)
        (write-region (concat (prin1-to-string piece) "\n")
         nil custom-file 'append)
        )))
   #+END_SRC
   Now make sure that our full name and email address are always defined.
   #+BEGIN_SRC emacs-lisp
(ensure-in-custom 'full-name "Enter your full name: ")
(ensure-in-custom 'email-address "Enter your email address: ")
   #+END_SRC


** Home and Dropbox Folder setup
   It is convenient to know where my "home" folder is (not the folder
   that Emacs thinks is home), and also where the Dropbox folder
   is. Later, we may define some shortcuts using these constants.
   #+BEGIN_SRC emacs-lisp
  (setq user-home-folder
        (file-name-as-directory
         ;; Windows doesn't use the ~ convention
         (if (eq system-type 'windows-nt)
             (substitute-in-file-name "$HOMEDRIVE$HOMEPATH")
             "~")))

  (setq user-dropbox-folder
        (file-name-as-directory
         (concat user-home-folder "Dropbox (MIT)")))
   #+END_SRC


** Custom Elisp
*** Editing Related
    Load some general use functions.
    #+BEGIN_SRC emacs-lisp
  (use-package my-functions
    :load-path "lisp/")
    #+END_SRC

*** Elisp Programming Related
    A macro that makes a single form
    into an anonymous function that calls the form
    #+BEGIN_SRC emacs-lisp
  (defmacro ↑ (form)
      `(lambda () (interactive) ,form))
  (defmacro → (λ)
      `(lambda (x) (apply #',λ x)))
    #+END_SRC


** General Settings
   These settings should always be present.
*** Better Defaults
    A no-frills package to set some sensible defaults.
    #+BEGIN_SRC emacs-lisp
  (use-package better-defaults
      :ensure t)
    #+END_SRC

*** Disable trailing newline
    #+BEGIN_SRC emacs-lisp
(setq-default mode-require-final-newline nil)
    #+END_SRC

*** Long lines mode
    #+BEGIN_SRC emacs-lisp
(set-default 'truncate-lines t)
    #+END_SRC
*** Auto Revert Mode
    No reason not to have files auto-revert in 2016.
    #+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
    #+END_SRC
*** Visuals
    #+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(setq inhibit-startup-message t)
    #+END_SRC

*** Tab Settings
    #+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
    #+END_SRC

*** Popwin
    Don't let temporary buffers annoy you! /Disabled because =popwin=
    makes looking up functions when programming painful./
    #+BEGIN_SRC emacs-lisp :tangle no
  (use-package popwin
      :ensure t
      :config
      (popwin-mode 1))
    #+END_SRC
*** Miscellaneous
    Always show column numbers
    #+BEGIN_SRC emacs-lisp
(column-number-mode t)
    #+END_SRC

    Never make me type =yes= or =no=.
    #+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

    Easier navigation with mark ring.
    #+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
    #+END_SRC

    Don't garbage collect so much.
    #+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 1024 1024 50))
    #+END_SRC

    Sane defaults for erasing region.
    #+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
    #+END_SRC

    Erase regions in a sane way.
    #+BEGIN_SRC emacs-lisp
  (defun kill-word-or-region ()
    (interactive)
    (if (not (use-region-p))
        (call-interactively 'backward-kill-word)
        (call-interactively 'kill-region)))

  (global-set-key "\C-w" 'kill-word-or-region)
  (global-set-key "\C-x\C-k" 'kill-region)
  (global-set-key "\C-c\C-k" 'kill-region)
    #+END_SRC

    If no line is selected, then just copy the line. See [[http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html][Xah Lee's code]]
    for the following implementation.
    #+BEGIN_SRC emacs-lisp :tangle no
  (defun xah-copy-line-or-region ()
    "Copy current line, or text selection.
  When called repeatedly, append copy subsequent lines.
  When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

  URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
  Version 2016-06-18"
    (interactive)
    (let (-p1 -p2)
      (if current-prefix-arg
          (setq -p1 (point-min) -p2 (point-max))
        (if (use-region-p)
            (setq -p1 (region-beginning) -p2 (region-end))
          (setq -p1 (line-beginning-position) -p2 (line-end-position))))
      (if (eq last-command this-command)
          (progn
            (progn ; hack. exit if there's no more next line
              (end-of-line)
              (forward-char)
              (backward-char))
            ;; (push-mark (point) "NOMSG" "ACTIVATE")
            (kill-append "\n" nil)
            (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
            (message "Line copy appended"))
        (progn
          (kill-ring-save -p1 -p2)
          (if current-prefix-arg
              (message "Buffer text copied")
            (message "Text copied"))))
      (end-of-line)
      (forward-char)
      ))
  (global-set-key (kbd "M-w") 'xah-copy-line-or-region) ;copy
    #+END_SRC



** General Mode (Keybinds!)
General mode to manage keybindings.
#+BEGIN_SRC emacs-lisp
  (use-package general
      :ensure t
      :config
      (general-define-key
       "M-t" 'ivy-switch-buffer
       "M-p" 'ace-window))
#+END_SRC


** Global Keybindings
*** F-keys
**** F8
     Set =<f8>= to editing this very file.
     #+BEGIN_SRC emacs-lisp
  (setq init-org-file
        (concat
         (file-name-as-directory (expand-file-name "org" user-emacs-directory))
         "my-init.org"))
  (global-set-key (kbd "<f8>") (↑ (find-file init-org-file)))
     #+END_SRC
**** F10
     Set =<f10>= to open the current buffer in Windows Explorer.
     Taken from here.
     #+BEGIN_SRC emacs-lisp
  (defun my-open-in-windows-explorer ()
    "Launch the windows explorer in the current directory and selects current file"
    (interactive)
    (w32-shell-execute
     "open"
     "explorer"
     (concat "/e,/select," (convert-standard-filename buffer-file-name))))

  (defun browse-file-directory ()
    "Open the current file's directory however the OS would."
    (interactive)
    (if default-directory
        (browse-url-of-file (expand-file-name default-directory))
      (error "No `default-directory' to open")))

  (if (or (eq system-type 'gnu/linux)
          (eq system-type 'darwin))
      (global-set-key [f10] #'browse-file-directory))

  (if (eq system-type 'windows-nt)
      (global-set-key [f10] 'my-open-in-windows-explorer))

     #+END_SRC
***** TODO Support other operating systems.
**** F1 and F2
     See [[Yasnippet]] and Hydra; there, =<f1>= and =<f2>= is also bound.
**** F5
     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "<f5>")
                       (lambda ()
                         (interactive)
                         (ansi-term "/usr/local/bin/bash")))
     #+END_SRC
     
*** Pause-key
    See section on [[Restart Emacs]].

*** Undo key
    Control-Z is otherwise useless because I always use Emacs with
    a GUI. Rebind it to undo.
    #+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-z") #'undo)
    #+END_SRC

*** Kill Buffer
    Instead of asking which buffer to kill, instead let's kill the current
    buffer if there is no prefix.
    #+BEGIN_SRC emacs-lisp
  (defun emacs-d-kill-a-buffer (askp)
    (interactive "P")
    (if askp
        (call-interactively #'kill-buffer)
      (kill-this-buffer)))

  (global-set-key (kbd "C-x k") #'emacs-d-kill-a-buffer)
    #+END_SRC


** Ido, Recentf, and Smex
*** General settings
    Ido is one of the reasons why Emacs is great! It takes a little bit of
    setting up to make it more comfortable to use.

    Enable virtual buffers: even if a buffer is closed, we still have
    access to it.
    #+BEGIN_SRC emacs-lisp
(setq ido-use-virtual-buffers t)
    #+END_SRC

    When a filename doesn't complete, ido will search recently used
    names. This is annoying, so disable it.
    #+BEGIN_SRC emacs-lisp
(setq ido-auto-merge-work-directories-length -1)
    #+END_SRC

    =Flx Ido= uses another algorithm to calculate matches which seems to
    work better than the default.
    #+BEGIN_SRC emacs-lisp
  (use-package flx-ido
      :ensure t
      :config (progn
                (flx-ido-mode 1)
                (ido-mode 1)))
    #+END_SRC

    Make the completion interface vertical; it is more legible this way.
    In addition, define up and down keys, because =<left>= and =<right>=
    arrows are too inconvenient.
    #+BEGIN_SRC emacs-lisp
(use-package ido-vertical-mode
    :ensure t
    :config
    (progn
      (ido-vertical-mode 1)
      (defun ido-define-keys () ;; C-n/p is more intuitive in vertical layout
        (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
        (define-key ido-completion-map (kbd "C-j") 'ido-next-match)
        (define-key ido-completion-map (kbd "C-k") 'ido-prev-match)
        (define-key ido-completion-map (kbd "C-p") 'ido-prev-match))
      (add-hook 'ido-setup-hook 'ido-define-keys)))
    #+END_SRC

*** Ido everywhere
    Use Ido for most completions; sadly this doesn't quite cover 100% of
    the cases yet, but it's close.
    #+BEGIN_SRC emacs-lisp
      (ido-everywhere)
      (use-package ido-completing-read+
          :preface
        (defvar ido-cur-list)
          :ensure t
          :init
          (progn
            (ido-ubiquitous-mode 1)
            (defmacro ido-ubiquitous-use-new-completing-read (cmd package)
              `(eval-after-load ,package
                 '(defadvice ,cmd (around ido-ubiquitous-new activate)
                   (let ((ido-ubiquitous-enable-compatibility nil))
                     ad-do-it)))))
          :config
          (progn
            (ido-ubiquitous-use-new-completing-read yas/expand 'yasnippet)
            (ido-ubiquitous-use-new-completing-read yas/visit-snippet-file 'yasnippet)))
    #+END_SRC
    The last two lines are used to make make completing with =yasnippet=
    work well.

**** TODO Investigate Helm?

*** Recentf
    Recentf supports Ido mode by keeping track of recently organized files.
    #+BEGIN_SRC emacs-lisp
(use-package recentf
    :config
  (progn
    (recentf-mode 1)
    (setq recentf-max-menu-items 500)))
    #+END_SRC

*** Smex
    Instead of using =Smex=, let's try out =counsel-M-x=.
    #+BEGIN_SRC emacs-lisp

    #+END_SRC



** Mac OS X specific settings
   We need let Emacs know about the the =LaTeX= path
   for =LaTeX= to work.
   #+BEGIN_SRC emacs-lisp
     (if (eq system-type 'darwin)
         (progn
           (defun set-exec-path-from-shell-PATH ()
             (let ((path-from-shell
                    (shell-command-to-string
                     "env TERM=vt100 /bin/sh -i -c 'echo $PATH'")))

               (setenv "PATH" path-from-shell)
               (setq exec-path (split-string path-from-shell path-separator))))

           (when (display-graphic-p) (set-exec-path-from-shell-PATH))

           (setq mac-option-key-is-meta t)
           (setq mac-command-key-is-meta t)
           (setq mac-command-modifier 'meta)

           (setenv "PATH" (concat "/usr/texbin" ":" (getenv "PATH")))
           (setenv "PATH" (concat "/Library/TeX/texbin" ":" (getenv "PATH")))
           (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))

           (setq exec-path
                 (append
                  '("/usr/local/bin"
                    "/Library/TeX/texbin")
                  exec-path))


           (setenv "PATH" (concat (getenv "PATH") ":/usr/bin"))))
   #+END_SRC


** Hydra
   Hydra mode is a new package that allow one to create custom interfaces
   like Org's export menu. It is great for mapping commands that one
   would like a hotkey for but isn't used enough to use an entire
   keybinding.
   #+BEGIN_SRC emacs-lisp
  (use-package hydra
      :ensure t)
   #+END_SRC

*** Yasnippet Hydra
    See [[Yasnippet]].

*** GUI Hydra
    I want a hydra to control various
    GUI elements (e.g. linum-mode, theme, font).

    #+BEGIN_SRC emacs-lisp
      (defhydra my-hydra-gui (:color blue)
        ("f" menu-set-font "Set font.")
        ("m" menu-bar-mode "Toggle menu bar.")
        ("t" (call-interactively #'counsel-load-theme) "Load theme")
        ("a"
         (progn (set-background-color "AntiqueWhite")
                (set-face-attribute 'fringe nil
                                    :foreground (face-foreground 'default)
                                    :background (face-background 'default)))
         "Antique white colors. No fringe."))

      (global-set-key (kbd "<f2>") #'my-hydra-gui/body)
    #+END_SRC



** Restart Emacs
   It's nice to have a shortcut to restart emacs on.
   #+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
      :ensure t
      :init
      (global-set-key (kbd "<pause>") #'restart-emacs))
   #+END_SRC


** Visual Regexp
   This is a great package that provides live feedback on regexps.
   #+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
      :ensure t
      :config
      (progn
        (global-set-key (kbd "M-r") 'vr/replace)))
   #+END_SRC


* Look and Feel
  Here, we install various themes.  Install =emacs24= themes and set up
  a font. I'm not sure at this point whether to simply /install/ the
  themes or actually activate them.
** Themes
   Install but defer.
   #+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
      :defer t
      :ensure t)
  (use-package ample-theme
      :defer t
      :ensure t)
  (use-package gotham-theme
      :defer t
      :ensure t)
  (use-package smyx-theme
      :defer t
      :ensure t)
  (use-package pastelmac-theme
      :defer t
      :ensure t)
  (use-package hc-zenburn-theme
      :defer t
      :ensure t)
  (use-package badwolf-theme
      :defer t
      :ensure t)
  (use-package tango-plus-theme
      :load-path "lisp/"
      :ensure t
      :defer t)
  (use-package zenburn-theme
      :ensure t
      :defer t
      :init
      ;; get the colors from hc-zenburn
      (setq zenburn-override-colors-alist
            '(("zenburn-fg+1"     . "#FFFFEF")
              ("zenburn-fg"       . "#DCDCCC")
              ("zenburn-fg-1"     . "#70705E")
              ("zenburn-bg-2"     . "#000000")
              ("zenburn-bg-1"     . "#202020")
              ("zenburn-bg-05"    . "#2D2D2D")
              ("zenburn-bg"       . "#313131")
              ("zenburn-bg+05"    . "#383838")
              ("zenburn-bg+1"     . "#3E3E3E")
              ("zenburn-bg+2"     . "#4E4E4E")
              ("zenburn-bg+3"     . "#5E5E5E")
              ("zenburn-red+1"    . "#E9B0B0")
              ("zenburn-red"      . "#D9A0A0")
              ("zenburn-red-1"    . "#C99090")
              ("zenburn-red-2"    . "#B98080")
              ("zenburn-red-3"    . "#A97070")
              ("zenburn-red-4"    . "#996060")
              ("zenburn-orange"   . "#ECBC9C")
              ("zenburn-yellow"   . "#FDECBC")
              ("zenburn-yellow-1" . "#EDDCAC")
              ("zenburn-yellow-2" . "#DDCC9C")
              ("zenburn-green-1"  . "#6C8C6C")
              ("zenburn-green"    . "#8CAC8C")
              ("zenburn-green+1"  . "#9CBF9C")
              ("zenburn-green+2"  . "#ACD2AC")
              ("zenburn-green+3"  . "#BCE5BC")
              ("zenburn-green+4"  . "#CCF8CC")
              ("zenburn-cyan"     . "#A0EDF0")
              ("zenburn-blue+1"   . "#9CC7FB")
              ("zenburn-blue"     . "#99DDE0")
              ("zenburn-blue-1"   . "#89C5C8")
              ("zenburn-blue-2"   . "#79ADB0")
              ("zenburn-blue-3"   . "#699598")
              ("zenburn-blue-4"   . "#597D80")
              ("zenburn-blue-5"   . "#436D6D")
              ("zenburn-magenta"  . "#E090C7")
              )))

  (use-package abyss-theme
      :ensure t
      :defer t)

  (use-package ujelly-theme
      :ensure t
      :defer t)

  (use-package monokai-theme
      :ensure t
      :defer t)

  (use-package darkokai-theme
      :ensure t
      :defer t)

  (use-package darkburn-theme
      :ensure t
      :defer t)
   #+END_SRC


** Fonts
*** Activating a font
    #+BEGIN_SRC emacs-lisp :tangle yes
      (defun my-set-face (font height)
        (set-face-attribute 'default nil
                            :family font
                            :height (* height 10)
                            :weight 'normal
                            :width 'normal))

      (if (eq system-type 'darwin)
          (set-face-attribute 'default nil
                              :family "Terminus (TTF)"
                              :height (* 13 10)
                              :weight 'bold))

      (if (eq system-type 'windows-nt)
          (my-set-face "Consolas" 12))

      (if (eq system-type 'gnu/linux)
          (set-face-attribute 'default nil
                              :family "Hack Regular"
                              :height (* 13 10)
                              :weight 'normal))


    #+END_SRC

*** TODO cycle between fonts
    Write a function (a la Spacemacs) that allows me to switch between fonts.
**** With ido support?

*** TODO Check whether the font exists


** Disable blinking cursor
   #+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
   #+END_SRC
   

* Abbrev Mode
  Load the fat fingers abbrev.
  #+BEGIN_SRC emacs-lisp
  (read-abbrev-file "~/.emacs.d/abbrev_def_fat_fingers")
  #+END_SRC


  I stole this from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][this blog post]].
  #+BEGIN_SRC emacs-lisp
  (setq abbrev-file-name "~/.emacs.d/abbrev_defs")

  (define-key ctl-x-map "\C-i"
    #'endless/ispell-word-then-abbrev)

  (defun endless/simple-get-word ()
    (car-safe (save-excursion (ispell-get-word nil))))

  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
  With prefix P, create local abbrev. Otherwise it will
  be global.
  If there's nothing wrong with the word at point, keep
  looking for a typo until the beginning of buffer. You can
  skip typos you don't want to fix with `SPC', and you can
  abort completely with `C-g'."
    (interactive "P")
    (let (bef aft)
      (save-excursion
        (while (if (setq bef (endless/simple-get-word))
                   ;; Word was corrected or used quit.
                   (if (ispell-word nil 'quiet)
                       nil ; End the loop.
                     ;; Also end if we reach `bob'.
                     (not (bobp)))
                 ;; If there's no word at point, keep looking
                 ;; until `bob'.
                 (not (bobp)))
          (backward-word)
          (backward-char))
        (setq aft (endless/simple-get-word)))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
                (bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
        (user-error "No typo at or before point"))))

  (setq save-abbrevs 'silently)
  (setq-default abbrev-mode t)
  #+END_SRC


* Avy, Swiper, and Counsel
  #+BEGIN_SRC emacs-lisp
    (use-package avy
        :ensure t)

    (use-package counsel
        :ensure t
        :diminish t
        :bind (("C-h f"   . counsel-describe-function)
               ("C-h v"   . counsel-describe-variable)
               ("M-y"     . counsel-yank-pop)
               ("M-x"     . counsel-M-x)
               ("C-x C-f" . counsel-find-file))
        :init
        (setq ivy-re-builders-alist
              '((t . ivy--regex-fuzzy)))
        :config
        (progn
          (add-to-list 'ivy-initial-inputs-alist
                       '(counsel-M-x . ""))
          (add-to-list 'ivy-initial-inputs-alist
                       '(counsel-describe-function . ""))
          (add-to-list 'ivy-initial-inputs-alist
                       '(counsel-describe-variable . ""))
          (counsel-mode)))

    (use-package ivy-rich
        :ensure t
        :bind (("C-x b" . ivy-switch-buffer))
        :init
        (progn
          (setq ivy-virtual-abbreviate 'full
                ivy-rich-switch-buffer-align-virtual-buffer t
                ivy-use-virtual-buffers t)))

    (with-eval-after-load 'ivy
      (ivy-set-display-transformer 'ivy-switch-buffer
                                   'ivy-rich-switch-buffer-transformer))
  #+END_SRC



* Ace-Window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
      :ensure t)
#+END_SRC


* Multiple Cursors
  Multiple cursors is lots of fun!
  #+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
      :ensure t)

  (global-set-key (kbd "M-j") 'mc/mark-next-like-this)
  (global-set-key (kbd "M-k") 'mc/mark-previous-like-this)
  (global-set-key (kbd "M-J") 'mc/mark-all-like-this)
  (global-set-key (kbd "M-n") 'mc/mark-next-like-this-word)
  #+END_SRC


* Yasnippet
** Introduction
   Yasnippet is very useful once setup correctly for each mode.
   The problem is that the =TAB= key is too useful in Org-mode and
   CDLaTeX mode. Hence, we need a couple functions to effectively
   enable and disable keys on the fly.
   #+BEGIN_SRC emacs-lisp
  (defun disable-yasnippet-tab-key ()
    (interactive)
    (define-key yas-minor-mode-map [(tab)]        nil)
    (define-key yas-minor-mode-map (kbd "TAB")    nil)
    (define-key yas-minor-mode-map (kbd "<tab>")  nil)
    (define-key yas-minor-mode-map (kbd "<backtab>")    nil)
    (define-key yas-minor-mode-map (kbd "<S-tab>")    nil)
    (define-key yas-minor-mode-map (kbd "TAB")    nil))

  (defun yas-keymap-is-active-p ()
    (eq (key-binding (kbd "C-g")) 'yas-abort-snippet))

  (defun setup-yasnippet-next-key (key)
    (local-set-key
     key
     (lambda ()
       (interactive)
       (if (yas-keymap-is-active-p)
           (call-interactively #'yas-next-field-or-maybe-expand)
         (call-interactively #'yas-expand)))))
   #+END_SRC

** Install and Disable Tab Key
   #+BEGIN_SRC emacs-lisp
  (use-package yasnippet
      :ensure t
      :diminish yas-minor-mode
      :init
      (progn
        (setq yas-snippet-dirs
              (list (concat user-emacs-directory
                            (file-name-as-directory "snippets")))))
      :config
      (progn
        (yas-global-mode)
        (disable-yasnippet-tab-key)))
   #+END_SRC

   Use ido prompting method.
   #+BEGIN_SRC emacs-lisp
  (setq yas-prompt-functions '(yas-ido-prompt yas-completing-prompt))
   #+END_SRC

** Yasnippet Hydra
   I believe that =yasnippet= is hugely good, but it takes some time to
   configure that the process is just slightly "too painful" that I avoid
   using it. Let's settle this with a neat =hydra= /globally/ bound to the ever so
   easy to reach =f1=.
   #+BEGIN_SRC emacs-lisp  
  (defhydra hydra-yasnippet (:color blue :hint nil)
      "
                  ^YASnippets^
    --------------------------------------------
      Modes:    Load/Visit:    Actions:

     _g_lobal  _d_irectory    _i_nsert
     _m_inor   _f_ile         _t_ryout
     _e_xtra   _l_ist         _n_ew
             _a_ll            _v_isit
    "
      ("d" yas-load-directory)
      ("e" yas-activate-extra-mode)
      ("i" yas-insert-snippet)
      ("f" yas-visit-snippet-file :color blue)
      ("n" yas-new-snippet)
      ("t" yas-tryout-snippet)
      ("l" yas-describe-tables)
      ("g" yas/global-mode)
      ("m" yas/minor-mode)
      ("a" yas-reload-all)
      ("v" yas-visit-snippet-file))

  (global-set-key (kbd "<f1>") 'hydra-yasnippet/body)
   #+END_SRC

   While in snippet mode, saving a snippet should just load and quit.
   #+BEGIN_SRC emacs-lisp
  (define-key snippet-mode-map (kbd "C-x C-s")
    #'yas-load-snippet-buffer-and-close)
   #+END_SRC

** TODO Add different folders for different modes of snippet files

** TODO Add a shortcut for visiting snippet

** TODO Add a shortcut for creating a snippet.
   

* Company Mode Goodness
** This is totally disabled for "typing pleasure!"
   Enabling company mode slowed the editor way down!
   And frankly it's not that useful.


** Introduction and Installation
   Decided to settle down once and forall on configuring company mode.
   The question is what to do with the tab key, though it seems that
   integrating with =hippie-expand= is a good choice.

   See [[https://github.com/cqql/dotfiles/blob/master/src/.emacs.d/init.org][cqql's emacs init.org]] for more details here.
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
      :ensure t
      :diminish company-mode
      :bind ("C-M-SPC" . company-complete)
      :init
      (progn
        (setf
         company-idle-delay                0
         company-minimum-prefix-length     2
         company-show-numbers              t
         company-selection-wrap-around     t
         company-tooltip-align-annotations t
         company-backends (list
                           #'company-capf
                           #'company-irony
                           (list #'company-dabbrev-code
                                 #'company-keywords)
                           #'company-files))

        (with-eval-after-load 'company
          (define-key company-active-map (kbd "TAB") 'company-select-next)
          (define-key company-active-map [tab] 'company-select-next)
          (define-key company-active-map (kbd "<S-tab>") 'company-select-previous)
          (define-key company-active-map [backtab] 'company-select-previous)))

      :config
      (global-company-mode t))

  (use-package company-dabbrev
      :init
    (setf company-dabbrev-ignore-case 'keep-prefix
          company-dabbrev-ignore-invisible t
          company-dabbrev-downcase nil))

  (use-package company-irony
      :ensure t)
   #+END_SRC


** Better Hippie Expand
   See [[https://www.reddit.com/r/emacs/comments/30h2gr/what_keybindings_do_you_use_for_completion/cpu1ui6][this reddit post]] for more details.
*** Better Hippie Expand
    See the same reddit post as above.
    #+BEGIN_SRC emacs-lisp
  (setq hippie-expand-try-functions-list
        '(;try-flyspell
          yas-hippie-try-expand 
          try-expand-dabbrev-visible 
          (lambda (arg) (call-interactively 'company-complete))
          ))
    #+END_SRC


* Smartparens
  =Smartparens= is almost a necessity in C-like languages; it is less
  essentially useless in Lisps because we will be using =paredit=. Also,
  smartparens is kind of useful in (La)TeX mode, so we should turn it on
  there in addition to Org mode.

  #+BEGIN_SRC emacs-lisp
    (use-package smartparens
        :ensure t
        :diminish smartparens-mode
        :init
        (progn
          (smartparens-global-mode 1)
          (show-smartparens-global-mode 1)
          (setq
           sp-highlight-pair-overlay nil
           sp-highlight-wrap-overlay nil
           sp-highlight-wrap-tag-overlay nil)
          (sp-local-pair 'LaTeX-mode "|" "|"))

        :config
        (progn
          (use-package smartparens-config)
          (add-hook 'emacs-lisp-mode-hook 'turn-off-smartparens-mode)
          (add-hook 'geiser-repl-mode-hook 'turn-off-smartparens-mode)
          (add-hook 'racket-mode-hook 'turn-off-smartparens-mode)
          (add-hook 'racket-repl-mode-hook 'turn-off-smartparens-mode)
          (sp-pair "`" nil :actions :rem)
          (sp-local-pair 'LaTeX-mode "|" "|")))
  #+END_SRC


* Paredit

  Enable =paredit=; I still prefer it over =smartparens= because it
  actually comes with a good set of keybindings, and old habits die
  hard.
  #+BEGIN_SRC emacs-lisp
  (use-package paredit
      :diminish paredit-mode
      :ensure t
      :config
      (progn
        (add-hook 'emacs-lisp-mode-hook       'enable-paredit-mode)
        (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
        (add-hook 'ielm-mode-hook             'enable-paredit-mode)
        (add-hook 'lisp-mode-hook             'enable-paredit-mode)
        (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
        (add-hook 'geiser-repl-mode-hook 'enable-paredit-mode)
        (add-hook 'racket-repl-mode-hook 'enable-paredit-mode)
        (add-hook 'racket-mode-hook 'enable-paredit-mode)
        (add-hook 'scheme-mode-hook           'enable-paredit-mode)
        (add-hook 'slime-repl-mode-hook       'enable-paredit-mode)
        (add-hook 'inferior-lisp-mode-hook 'enable-paredit-mode)))
  #+END_SRC



* Org Mode
** Appearance
   Since we use Org Babel so often, it is important to highlight
   code in source blocks.
   #+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
   #+END_SRC

   Fontify the whole heading to make it look nice.
   #+BEGIN_SRC emacs-lisp
  (setq org-fontify-whole-heading-line t)
   #+END_SRC


** Org as a Word Processor
   See [[http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html][Org as a Word Processor]] for more details.
*** Get rid of distraction
    #+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
    #+END_SRC

*** Better Bullets
    #+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    #+END_SRC

*** Better Header Bullets
    #+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
    #+END_SRC

*** Better Headers
    I don't quite like how this looks yet, so I will skip it.
    #+BEGIN_SRC emacs-lisp :tangle no
  (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                               ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                               ((x-list-fonts "Verdana")         '(:font "Verdana"))
                               ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                               (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color     (face-foreground 'default nil 'default))
         (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces 'user
                            `(org-level-8 ((t (,@headline ,@variable-tuple))))
                            `(org-level-7 ((t (,@headline ,@variable-tuple))))
                            `(org-level-6 ((t (,@headline ,@variable-tuple))))
                            `(org-level-5 ((t (,@headline ,@variable-tuple))))
                            `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                            `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
                            `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
                            `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
                            `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))

    #+END_SRC


** Editing features
   We can also allow plain lists starting with alphabet instead
   of just numbers.
   #+BEGIN_SRC emacs-lisp
  (setq org-list-allow-alphabetical t)
   #+END_SRC

   Let's be smart about invisible edits.
   #+BEGIN_SRC emacs-lisp
  (setq org-catch-invisible-edits 'show-and-error)
   #+END_SRC

   We always want to turn on =auto-fill-mode= in Org files, so that lines
   automagically wrap at 80 columns.
   #+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'auto-fill-mode)
   #+END_SRC


** Directory structure
   Set the *default directory* for Org-mode.
   #+BEGIN_SRC emacs-lisp
  (let ((org-folder
         (file-name-as-directory (concat user-dropbox-folder "Org"))))
    (setq org-directory org-folder))
   #+END_SRC


** Custom key binds
   Set the global hotkeys which are commended in the manual.
   #+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)

  (define-key org-mode-map (kbd "M-t")
    (lambda () (interactive)
            (setq current-prefix-arg '(4))
            (call-interactively 'org-time-stamp-inactive)))
   #+END_SRC
  
   We need an easier key on LaTeX. In future Org versions, use
   =org-toggle-latex-fragment=.
   #+BEGIN_SRC emacs-lisp
  (org-defkey org-mode-map (kbd "C-.") 'org-preview-latex-fragment)
   #+END_SRC


** Support for LaTeX in Org
*** Inside Org Mode
    Larger LaTeX fonts; it seems that 1.4 is too large, so let's leave this
    *OFF* for now.
    #+BEGIN_SRC emacs-lisp :tangle yes
  (plist-put org-format-latex-options :scale 1.4)
  (plist-put org-format-latex-options :html-scale 1.4)
    #+END_SRC

    Autoload CDLaTeX mode and RefTeX.
    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
      (add-hook 'org-mode-hook (lambda () (interactive) (reftex-mode t)))
    #+END_SRC

    Turn on LaTeX syntax highlighting.
    #+BEGIN_SRC emacs-lisp
  (setq org-highlight-latex-and-related '(latex script))
    #+END_SRC

    Make smart-parens do their thing.
    #+BEGIN_SRC emacs-lisp
  (sp-local-pair 'org-mode "$" "$")
    #+END_SRC

**** TODO Make the dollar sign $ type actual dollars.

*** Exporting to LaTeX
**** Margins and Microtype
     #+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("final" "microtype"))
  (add-to-list 'org-latex-packages-alist '("margin=1in" "geometry"))
     #+END_SRC
**** TODO Theorems



**** Colors in exported code blocks.
     Perhaps =minted= is the better choice, but there are apparently "repercussions"
     that I don't want to deal with, as outlined in the documentation
     of =org-latex-listings=.
     #+BEGIN_SRC emacs-lisp
  (setq org-latex-listings 'minted)
  (require 'ox-latex)
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
      "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
      "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
      ))
     #+END_SRC

**** TODO Insert the appropriate packages
     - geometry
     - enumitem
     - mathtools
     - microtype?
**** TODO choose a set of fonts?
**** TODO Need to configure how the title looks


** HTML Export settings
   Highlight code blocks in HTML.
   #+BEGIN_SRC emacs-lisp
  (use-package htmlize
      :ensure t)
   #+END_SRC


   The footer is somewhat useless; don't show it at all.
   #+BEGIN_SRC emacs-lisp
  (setq org-html-validation-link nil)
   #+END_SRC

   Turn off TOC and and headline numbering in HTML.
   #+BEGIN_SRC emacs-lisp :tangle no
  (defun my-org-change-html-options (plist backend)
    (when (eq backend 'html)
      (plist-put plist :with-toc nil)
      (plist-put plist :section-numbers nil)
      ))

  (add-to-list 'org-export-filter-options-functions #'my-org-change-html-options)
   #+END_SRC

   We want to use the [[https://cmcenroe.me/writ/][Writ CSS]] style, so we need to wrap everything
   around an article tag.
   #+BEGIN_SRC emacs-lisp
  (setq org-html-divs
        '((preamble "div" "preamble")
          (content "article" "")
          (postamble "div" "postamble")))
   #+END_SRC


** Easy templates
   Since =emacs-lisp= code blocks are so prevalent,
   make a new template key for them, using =E=.
   #+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
   #+END_SRC


** Org Settings
   Use =ido= for completion.
   #+BEGIN_SRC emacs-lisp
(setq org-completion-use-ido t)
(setq org-outline-path-complete-in-steps nil)
   #+END_SRC



* Pandoc Mode
  Pandoc is probably the most versatile document converter at the
  moment. Let's use it until we are more comfortable wtih Org=mode.
  #+BEGIN_SRC emacs-lisp
  (use-package pandoc-mode
      :ensure t)
  #+END_SRC


* Emacs-Lisp
  Use CL lisp indent; it seems preferable in these =use-package=
  macros.
  #+BEGIN_SRC emacs-lisp
  (setq lisp-indent-function 'common-lisp-indent-function)
  #+END_SRC

  See the section [[Paredit]] that turns on =paredit-mode=
  for elisp files.

  Some useful keybindings
  #+BEGIN_SRC emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "C-c C-b") #'eval-buffer)
  (define-key emacs-lisp-mode-map (kbd "<C-return>") #'eval-region)
  #+END_SRC


* LaTeX
  Emacs is the best text editor for editing plain TeX and LaTeX files; I
  am slowly in the process of migrating from TeX/LaTeX to Org, but that
  process will require sometime as RefTeX does not yet work gracefully
  with LaTeX. Without further ado ...

** AucTeX
   AucTeX is an improved mode for editing LaTeX files; we will not use
   most of its features since the minor mode CDLaTeX subsumes some
   of them.

*** Installation
    First make sure that =auctex= is installed
    #+BEGIN_SRC emacs-lisp
  (use-package tex-site
      :ensure auctex)
    #+END_SRC

*** Parsing
    Enable parse on load and save (useful for detecting plain TeX
    versus LaTeX).
    #+BEGIN_SRC emacs-lisp
(setq TeX-parse-self t)
(setq TeX-auto-save t)
(setq-default TeX-master nil)
    #+END_SRC

*** Annoyance Fixes
    This really should belong in the main branch of AUCTeX.
    #+BEGIN_SRC emacs-lisp
  (setq texmathp-tex-commands
        '(("\\tag" arg-off)
          ("\\tag*" arg-off)))
    #+END_SRC
*** Producing DVI vs PDF
    We can configure AucTeX to automatically produce PDFs, but
    I actually prefer DVI files, so let's leave the following setting
    off for now.
    #+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
  (setq TeX-PDF-via-dvips-ps2pdf nil)
  (setq TeX-source-correlate-mode t)
    #+END_SRC

*** Arara
    Arara is a snazzy tool! See
    [[http://emacs.stackexchange.com/questions/9715/arara-integration-in-emacs][this Emacs.SE answer]] for how to set it up.
    #+BEGIN_SRC emacs-lisp
(eval-after-load "tex"
  '(add-to-list 'TeX-command-list
        '("Arara" "arara %s" TeX-run-TeX nil t :help "Run Arara.")))
    #+END_SRC

*** Viewers 
    For Mac OS, =Skim= is the best PDF viewer (even though it is not that
    good). For Windows, it is clearly SumatraPDF. On Linux, evince and
    xdvi are quite good. I stole the code below from somewhere (on
    TeX.SX). It works, and I don't want to mess with it.
    #+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (setq
       ;; Set the list of viewers for Mac OS X.
       TeX-view-program-list
       '(("Preview.app" "open -a Preview.app %o")
         ("Skim" "open -a Skim.app %o")
         ("displayline" "displayline %n %o %b")
         ("open" "open %o"))
       ;; Select the viewers for each file type.
       TeX-view-program-selection
       '((output-dvi "open")
         (output-pdf "Skim")
         (output-html "open"))))

  (if (eq system-type 'windows-nt)
      (progn 
        (setq TeX-output-view-style
              '("^pdf$" "." "SumatraPDF.exe -reuse-instance %o"))
        (setq TeX-view-program-list
              '(("SumatraPDF" "\"C:/Program Files/SumatraPDF/SumatraPDF.exe\" -reuse-instance %o")))
        (setq TeX-view-program-selection '((output-pdf "SumatraPDF")
                                           (output-dvi "Yap")))))

  (when (eq system-type 'gnu/linux)
    (setq TeX-view-program-list '(("MUPDF" "mupdf -r 153 %o")
                                  ("ZATHURA" "zathura %o")
                                  ("LLPP" "llpp %o")
                                  ("XDVI" "xdvi %o")))
    (setq TeX-view-program-selection '(
                                       (output-pdf "ZATHURA")
                                       (output-pdf "LLPP")
                                       (output-pdf "Evince")
                                       (output-dvi "xdvi"))))


  ;; ;; See http://tex.stackexchange.com/questions/207889/how-to-set-up-forward-inverse-searches-with-auctex-and-zathura
  ;; (setq zathura-procs ())
  ;; (defun zathura-forward-search ()
  ;;   ;; Open the compiled pdf in Zathura with synctex. This is complicated since
  ;;   ;; 1) Zathura refuses to acknowledge Synctex directive if the pdf is not
  ;;   ;; already opened
  ;;   ;; 2) This means we have to bookkeep open Zathura processes ourselves: first
  ;;   ;; open a new pdf from the beginning, if it is not already open. Then call
  ;;   ;; Zathura again with the synctex directive.
  ;;   (interactive)
  ;;   (let* ((zathura-launch-buf (get-buffer-create "*Zathura Output*"))
  ;;          (pdfname (TeX-master-file "pdf"))
  ;;          (zatentry (assoc pdfname zathura-procs))
  ;;          (zatproc (if (and zatentry (process-live-p (cdr zatentry)))
  ;;                       (cdr zatentry)
  ;;                     (progn
  ;;                       (let ((proc (progn (message "Launching Zathura")
  ;;                                          (start-process "zathura-launch"
  ;;                                                         zathura-launch-buf "zathura"
  ;;                                                          "-x" "emacsclient +%{line} %{input}" pdfname))))
  ;;                         (when zatentry
  ;;                           (setq zathura-procs (delq zatentry zathura-procs)))
  ;;                         (add-to-list 'zathura-procs (cons pdfname proc))
  ;;                         (set-process-query-on-exit-flag proc nil)
  ;;                         proc))))
  ;;          (pid (process-id zatproc))
  ;;          (synctex (format "%s:0:%s"
  ;;                           (TeX-current-line)
  ;;                           (TeX-current-file-name-master-relative)))
  ;;          )
  ;;     (start-process "zathura-synctex" zathura-launch-buf "zathura" "--synctex-forward" synctex pdfname)
  ;;     (start-process "raise-zathura-wmctrl" zathura-launch-buf "wmctrl" "-a" pdfname)
  ;;     ))
    #+END_SRC

*** Minor modes for editing LaTeX
    Hard-wrap and disable =electric-indent-mode= which messes
    up AucTeX's internal indentation code. This actually depends
    on AucTeX since it defines =LaTeX-mode-hook=.
    #+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'tex
    (add-hook 'LaTeX-mode-hook (↑ (electric-indent-mode -1))))
    #+END_SRC

*** Electric Math mode
    This seems helpful. See the [[http://ftp.gnu.org/gnu/auctex/11.89-extra/auctex.pdf][AucTeX manual]] for more details.
    #+BEGIN_SRC emacs-lisp
  (add-hook 'plain-TeX-mode-hook
             (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
                             (cons "$" "$"))))
  (add-hook 'LaTeX-mode-hook
             (lambda () (set (make-variable-buffer-local 'TeX-electric-math)
                             (cons "\\(" "\\)"))))
    #+END_SRC


** RefTeX
*** Installation
    #+BEGIN_SRC emacs-lisp
  (use-package reftex ; TeX/BibTeX cross-reference management
      :defer t
      :init
      (progn
        (add-hook 'LaTeX-mode-hook #'reftex-mode)
        (setq reftex-plug-into-AuCTeX t)))

(setq reftex-label-alist nil)
    #+END_SRC

*** Cleverref
    See [[http://tex.stackexchange.com/questions/119253/cleveref-auctex-and-reftex-set-up/119273#119273][this TeX.SX question]] for details.
    #+BEGIN_SRC emacs-lisp
(eval-after-load
    "latex"
  '(TeX-add-style-hook
    "cleveref"
    (lambda ()
      (if (boundp 'reftex-ref-style-alist)
      (add-to-list
       'reftex-ref-style-alist
       '("Cleveref" "cleveref"
         (("\\cref" ?c) ("\\Cref" 13) ("\\cpageref" ?d) ("\\Cpageref" ?D)))))
      (reftex-ref-style-activate "Cleveref")
      (TeX-add-symbols
       '("cref" TeX-arg-ref)
       '("Cref" TeX-arg-ref)
       '("cpageref" TeX-arg-ref)
       '("Cpageref" TeX-arg-ref)))))
    #+END_SRC


** CDLaTeX
   CDLaTeX is the last piece of the triumphrate of
   LaTeX facilities for LaTeX.

*** Installation
    #+BEGIN_SRC emacs-lisp
  (use-package cdlatex
      :ensure t
      :load-path "lisp/")
    #+END_SRC

    Now we can always turn it on, both for LaTeX and for TeX.
    #+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook 'turn-on-cdlatex)
  (add-hook 'LaTeX-mode-hook 'turn-on-cdlatex)
    #+END_SRC


*** Automatic Parentheses
    Thankfully, [[Smartparens][=smartparens=]] can be ued in LaTeX mode no problem;
    therefore, we don't need to have CDLaTeX do the work.

    Also, LaTeX-combo-keys, could also disable the caret.
    #+BEGIN_SRC emacs-lisp
  (setq cdlatex-paired-parens "$")
  ;; (define-key cdlatex-mode-map "$" nil)
  (define-key cdlatex-mode-map "(" nil)
  (define-key cdlatex-mode-map "{" nil)
  (define-key cdlatex-mode-map "[" nil)
  (define-key cdlatex-mode-map "|" nil)
  (define-key cdlatex-mode-map "<" nil)
  (define-key cdlatex-mode-map "^" nil)
    #+END_SRC


*** Templates
    Pressing =<tab>= in CDLaTeX, among other things, active a poor man's
    version of =yasnippet=. It is preferable to =yasnippet= because it
    integrates better with the rest of CDLaTeX.

**** Math Shortcuts
     #+BEGIN_SRC emacs-lisp
  (defun simple-math-template (key docstring expansion)
    `(,key ,docstring ,expansion cdlatex-position-cursor nil nil t))

  (setq my-math-templates 
        (mapcar (→ simple-math-template)
                '(
                  ("bi" "Insert \\binom{}{}" "\\binom{?}{}")
                  ("ggr(" "Insert \biggl( \biggr)" "\\biggl(? \\biggr")
                  ("ggr|" "Insert \biggl| \biggr|" "\\biggl|? \\biggr|")
                  ("ggr{" "Insert \biggl\{ \biggr\}" "\\biggl\\{? \\biggr\\")
                  ("ggr[" "Insert \biggl[ \biggr]" "\\biggl[? \\biggr")
                  ("ce" "Insert ceilings" "\\lceil? \\rceil")
                  ("fl" "Insert floors" "\\lfloor? \\rfloor")
                  ("ggrce" "Insert ceilings" "\\biggl\\lceil? \\biggr\\rceil")
                  ("ggrfl" "Insert floor" "\\biggl\\lfloor? \\biggr\\rfloor")
                  ("int" "Insert integrals without limits" "\\int_{?}^{}")
                  ("sum" "Insert sums without limits" "\\sum_{?}^{}")
                  ("prod" "Insert products without limits" "\\prod_{?}^{}")
                  ("prodl" "Insert products" "\\prod\\limits_{?}^{}"))))

  (setq cdlatex-command-alist my-math-templates)

  (setq cdlatex-math-modify-alist
        '((?t "\\text" nil t nil nil)
          (?s "\\mathscr" nil t nil nil)
          ))
     #+END_SRC


**** Environment support
     To support inserting environments, we need to setup both AUCTeX,
     RefTeX, and CDLaTeX in tandem. For example, to setup the axiom
     environment, we need to do the following (this code block is not
     tangled)
     #+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list
   'reftex-label-alist
   '("axiom" ?a "ax:" "~\\ref{%s}" t ("axiom" "ax.")))

  (LaTeX-add-environments
   '("axiom" LaTeX-env-label))

  (add-to-list
   'cdlatex-command-alist
   '("axm" "Insert axiom env" "" cdlatex-environment ("axiom") t nil))

  (add-to-list
   'cdlatex-env-alist
   '("axiom" "\\begin{axiom}\nAUTOLABEL\n?\n\\end{axiom}\n" nil))
     #+END_SRC

     Now add the environments.
     #+BEGIN_SRC emacs-lisp
  (defun my-setup-latex-environment (env ref-char ref-key shortcut doc)
    (add-to-list 'reftex-label-alist
                 (list env
                       ref-char
                       (concat ref-key ":")
                       "~\\ref{%s}"
                       t
                       `(,env ,(concat (substring env 0 2) "."))))

    (LaTeX-add-environments
     `(,env LaTeX-env-label))

    (add-to-list 'cdlatex-command-alist
                 `(,shortcut ,doc "" cdlatex-environment ,(list env) t nil))

    (add-to-list 'cdlatex-env-alist
                 (list env
                       (format "\\begin{%s}\nAUTOLABEL\n?\n\\end{%s}" env env)
                       nil))
    )

  (with-eval-after-load "latex"
    (mapcar (→ my-setup-latex-environment)
            '(("axiom" ?a "ax" "axm" "Insert an axiom.")
              ("theorem" ?t "thr" "thr" "Insert a theorem.")
              ("lemma" ?l "lem" "lem" "Insert a lemma.")
              ("example" ?x "ex" "exa" "Insert an example.")
              ("claim" ?c "clm" "clm" "Insert a claim.")
              ("proposition" ?p "prop" "prop" "Insert a proposition.")
              ("wts" ?w "wts" "wts" "Insert a 'want to show'.")
              ("definition" ?d "def" "def" "Insert a definition."))))

  (add-to-list 'cdlatex-command-alist
               '("pr" "Insert proof env" "" LaTeX-environment-menu ("proof") t nil))

  (add-to-list 'cdlatex-command-alist
               '("sp" "Insert split env" "" LaTeX-environment-menu ("split") nil t))
     #+END_SRC


     
** Pretty Symbols
   Pretty symbols help when there is a lot of Greek letters. This doesn't
   quite work well yet (can't turn off the triangles),
   so let's not tangle it for now.
   #+BEGIN_SRC emacs-lisp :tangle no
  (use-package magic-latex-buffer
      :ensure t
      :init
      (progn
        (setq magic-latex-enable-block-highlight nil
              magic-latex-enable-suscript        nil
              magic-latex-enable-pretty-symbols  t
              magic-latex-enable-block-align     nil
              magic-latex-enable-inline-image    nil
              magic-latex-enable-minibuffer-echo nil)))

  (with-eval-after-load 'latex
    (define-key LaTeX-mode-map (kbd "<f3>") 'magic-latex-buffer)
    )
   #+END_SRC


** Shortcuts
*** Compiling
    Compiling shouldn't have to be =C-c C-c <RET>=, and viewing
    shouldn't have to be =C-c C-v=. Rebind these keys to hotkeys that are
    normally of no use anyway.
    #+BEGIN_SRC emacs-lisp
  (defun latex-compile ()
    (interactive)
    (save-buffer)
    (TeX-command "LaTeX" 'TeX-master-file))

  (defun my-tex-compile ()
    (interactive)
    (save-buffer)
    (TeX-command "TeX" 'TeX-master-file))


  (eval-after-load 'latex
    '(define-key LaTeX-mode-map (kbd "C-t") 'latex-compile))

  (eval-after-load 'latex
    '(define-key LaTeX-mode-map (kbd "C-v") 'TeX-view))

  (eval-after-load 'plain-tex
    '(define-key plain-TeX-mode-map (kbd "C-t") 'my-tex-compile))

  (eval-after-load 'plain-tex
    '(define-key plain-TeX-mode-map (kbd "C-v") 'TeX-view))
    #+END_SRC

*** Moving
    I don't use the commands that move between environments often enough
    to justify  entire keybindings, so disable them.
    #+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'latex
    (define-key LaTeX-mode-map (kbd "C-M-a") nil)
    (define-key LaTeX-mode-map (kbd "C-M-e") nil))
    #+END_SRC

*** Custom symbols
    #+BEGIN_SRC emacs-lisp
  (defun insert-then-position (str)
    (interactive)
    (insert str)
    (cdlatex-position-cursor))

  (defmacro my-define-latex-keys
      (mode-map kbd combo)
    `(define-key ,mode-map (kbd ,kbd) (↑ (insert-then-position ,combo))))


  (with-eval-after-load 'latex
    (my-define-latex-keys LaTeX-mode-map "C-o" "\\circ")
    (my-define-latex-keys LaTeX-mode-map "C-1" "\\frac{?}{}")
    (my-define-latex-keys LaTeX-mode-map "M-i" "\\int_{?}^{}")
    (my-define-latex-keys LaTeX-mode-map "M-s" "\\sum_{?}^{}")
    (my-define-latex-keys LaTeX-mode-map "M-h" "\\text{?}")
    (my-define-latex-keys LaTeX-mode-map "M-t" "\\text{?}")
    (my-define-latex-keys LaTeX-mode-map "M-q" "\\quad?")
    (my-define-latex-keys LaTeX-mode-map "M-Q" "\\qquad?")
    (my-define-latex-keys LaTeX-mode-map "C-M-q" "\\qquad?")
    (my-define-latex-keys LaTeX-mode-map "s-f" "{? \\over }")
    (my-define-latex-keys LaTeX-mode-map "C-2" "\\sqrt{?}")
    (my-define-latex-keys LaTeX-mode-map "C-9" "\\biggl( ? \\biggr)")
    (my-define-latex-keys LaTeX-mode-map "C-0" "\\biggl[ ? \\biggr]")
    (my-define-latex-keys LaTeX-mode-map "C-." "\\{ ? \\}")
    (my-define-latex-keys LaTeX-mode-map "C-," "\\langle ? \\rangle")
    )

  (with-eval-after-load 'plain-tex
    (my-define-latex-keys plain-TeX-mode-map "C-1" "{? \\over }")
    (my-define-latex-keys plain-TeX-mode-map "M-p" "\\proclaim ?")
    (my-define-latex-keys plain-TeX-mode-map "M-P" "\\proclaimit ?")
    (my-define-latex-keys plain-TeX-mode-map "M-i" "\\int_{?}^{}")
    (my-define-latex-keys plain-TeX-mode-map "M-s" "\\sum_{?}^{}")
    (my-define-latex-keys plain-TeX-mode-map "M-h" "\\hbox{?}")
    (my-define-latex-keys plain-TeX-mode-map "M-t" "\\hbox{?}")
    (my-define-latex-keys plain-TeX-mode-map "M-q" "\\quad?")
    (my-define-latex-keys plain-TeX-mode-map "M-Q" "\\qquad?")
    (my-define-latex-keys plain-TeX-mode-map "C-M-q" "\\qquad?")
    (my-define-latex-keys plain-TeX-mode-map "s-f" "{? \\over }")
    (my-define-latex-keys plain-TeX-mode-map "C-4" "$$\n?\n$$")
    (my-define-latex-keys plain-TeX-mode-map "C-2" "\\sqrt{?}")
    (my-define-latex-keys plain-TeX-mode-map "C-3" "\\hbox{?}")
    (my-define-latex-keys plain-TeX-mode-map "C-9" "\\biggl( ? \\biggr)")
    (my-define-latex-keys plain-TeX-mode-map "C-0" "\\biggl[ ? \\biggr]")
    (my-define-latex-keys plain-TeX-mode-map "C-." "\\{ ? \\}")
    (my-define-latex-keys plain-TeX-mode-map "C-," "\\langle ? \\rangle")
    (my-define-latex-keys plain-TeX-mode-map "C-o" "\\circ?")
  )
    #+END_SRC


*** TODO Make M-u insert an underscore, M-i insert caret, and M-o insert both
    Next define easy shortcuts for inserting underscores
    and the like.


** Yasnippets
   Enable =yasnippets= through =C-;=, which isn't used anywhere.
   #+BEGIN_SRC emacs-lisp
  (defun my-TeX-yasnippet-common-hook ()
    (setup-yasnippet-next-key (kbd "C-;"))
    (setup-yasnippet-next-key (kbd "<C-tab>")))

  (add-hook 'plain-TeX-mode-hook 'my-TeX-yasnippet-common-hook)
  (add-hook 'LaTeX-mode-hook 'my-TeX-yasnippet-common-hook)
   #+END_SRC


** Flyspell Mode
   #+BEGIN_SRC emacs-lisp
     (add-hook 'LaTeX-mode-hook     (lambda () (interactive) (flyspell-mode t)))
     (add-hook 'plain-TeX-mode-hook (lambda () (interactive) (flyspell-mode t)))

     (with-eval-after-load 'flyspell
       (define-key flyspell-mode-map (kbd "C-;") nil))
   #+END_SRC

   
** Disable Company
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook (↑ (company-mode -1)))
  (add-hook 'TeX-mode-hook (↑ (company-mode -1)))
#+END_SRC

** My Own Package!
   Load my own package after everything has loaded.
   #+BEGIN_SRC emacs-lisp
  (use-package legendre-latex-key-combo
      :load-path "lisp/")
   #+END_SRC


* Emacs Speaks Statistics
** Installation
   As opposed to using RStudio, let's use ESS because it's getting lots
   of great reviews!
   #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ess
      :ensure t
      :init
      (setq ess-R-smart-operators t))

  (use-package ess-smart-equals
     :ensure t)

  (with-eval-after-load 'ess-smart-equals
    (add-hook 'ess-mode-hook 'ess-smart-equals-mode)
    (add-hook 'ess-mode-hook 'electric-pair-mode)
    (add-hook 'inferior-ess-mode-hook 'ess-smart-equals-mode))
   #+END_SRC

** Keybinds
   Certain keybinds are nice to have in a =.R= buffer.
   #+BEGIN_SRC emacs-lisp :tangle yes
  (with-eval-after-load 'ess
    (define-key  ess-mode-map (kbd "C-t") 'ess-switch-to-inferior-or-script-buffer)
    (define-key  inferior-ess-mode-map (kbd "C-t") 'ess-switch-to-inferior-or-script-buffer))
   #+END_SRC

** Customization
   See [[https://stat.ethz.ch/pipermail/ess-help/2009-July/005456.html][this post]] to make the ESS R console screen automagically scale
   with window size. (The bottom snippet is original though!)
   #+BEGIN_SRC emacs-lisp :tangle yes
  (defun my-ess-post-run-hook ()
    (ess-execute-screen-options))

  (add-hook 'ess-post-run-hook 'my-ess-post-run-hook)

  (defun my-ess-execute-screen-options (foo)

    (ess-execute-screen-options))

  (add-hook 'inferior-ess-mode-hook
            (lambda ()
              (setq-local window-size-change-functions
                          '(my-ess-execute-screen-options))))

  (add-hook 'window-configuration-change-hook
            (lambda ()
              ;; R-buffer-regex-string is a regexp that matches
              ;; strings of the type {*R*, *R:dddd*}, where dddd
              ;; is any sequence of digits.

              ;; The idea is that R buffers will have buffer names
              ;; that match this regexp. So if we are in a window
              ;; that changes and we are active in the R buffer,
              ;; the window size changes.

              ;; It's not perfect (i.e. what happens if we change a window
              ;; that contains a R buffer but we are not looking at it?)
              ;; but it works for now.

              ;; Perhaps this kludge can be fixed, but some other time ...
            
              (let ((R-buffer-regex-string "\\*R\\(?::[[:digit:]]+\\)?\\*"))
                (if (string-match-p R-buffer-regex-string (buffer-name))
                    (ess-execute-screen-options)))))

   #+END_SRC


* Clojure

  




* SLIME and SBCL
  Setting up =SLIME= to use with Steel Bank Common Lisp.
  #+BEGIN_SRC emacs-lisp
  (use-package slime
      :ensure t
      :init
      (progn
        (setq inferior-lisp-program "/usr/bin/sbcl")
        (setq slime-contribs '(slime-fancy)))

      :config
      (progn
        (add-hook 'lisp-mode-hook (lambda () (slime-mode t)))))


  #+END_SRC


* Haskell
  Haskell is the cool kid on the block, and it is time to get
  comfortable with it to do more scripting.
  #+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
      :ensure t
      :config
      (progn
        (add-hook 'haskell-mode-hook 'haskell-indentation-mode)
        (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
        (add-hook 'haskell-mode-hook 'turn-on-haskell-unicode-input-method)))
  #+END_SRC




* Racket
** Geiser Mode [not used for now]
   =Geiser= mode is good enough to use for Racket (Scheme).
   #+BEGIN_SRC emacs-lisp :tangle no
  (use-package geiser
      :ensure t
      :init
      (setq geiser-active-implementations '(racket))
      :config
      (add-hook 'geiser-mode-hook #'comment-auto-fill))


  (with-eval-after-load 'geiser-repl
    (define-key geiser-repl-mode-map (kbd "C-l") #'legendre6891/my-clear))
   #+END_SRC

** Racket Mode
   Let's try =racket-mode= instead of =geiser=.
   #+BEGIN_SRC emacs-lisp
  (use-package racket-mode
      :ensure t)

  (with-eval-after-load 'racket-repl
    (define-key racket-repl-mode-map (kbd "C-l") #'legendre6891/my-clear))
   #+END_SRC


* Python
Let's try using =elpy=.
#+BEGIN_SRC emacs-lisp
  (use-package elpy
      :ensure t
      :init
      (elpy-enable))
#+END_SRC

* Julia
** TODO Write some configurations --- broken at the moment
   #+BEGIN_SRC emacs-lisp :tangle no
  (use-package julia-mode
      :ensure t)

  (use-package julia-shell-mode
      :ensure julia-shell)

  (defun my-julia-mode-hooks ()
    (require 'julia-shell-mode))
  (add-hook 'julia-mode-hook 'my-julia-mode-hooks)
  (define-key julia-mode-map (kbd "C-c C-c") 'julia-shell-run-region-or-line)
  (define-key julia-mode-map (kbd "C-c C-s") 'julia-shell-save-and-go)
   #+END_SRC


* J mode
  I have a soft spot for the J programming language---guess it appeals
  to my inner mathematician + hacker meld because it is so terse?
  Anyhow, here is support for the J lang.
  #+BEGIN_SRC emacs-lisp
  (use-package j-mode
      :ensure t
      :init
      (custom-set-faces
       '(j-verb-face ((t (:foreground "Red"))))
       '(j-adverb-face ((t (:foreground "DarkGreen"))))
       '(j-conjunction-face ((t (:foreground "Blue"))))
       '(j-other-face ((t (:foreground "Black")))))
      )
  #+END_SRC





* CC modes
  This section sets up =Emacs= to handle editing C and C++ files.
** Basic customizations
   Use a sane formatting standard.
   #+BEGIN_SRC emacs-lisp
  (setq c-default-style "k&r"
        c-basic-offset 4)

  (add-hook 'c-mode-common-hook
            (lambda ()
              (electric-pair-mode t)
              (electric-indent-mode t)))
   #+END_SRC

** Format using Clang Format
   =clang-format= should be the "go to" tool to format C and C++ files.
   #+BEGIN_SRC emacs-lisp
  (use-package clang-format
      :ensure t
      :config
      (with-eval-after-load 'cc-mode
        (define-key c++-mode-map (kbd "M-=") #'clang-format-buffer)))

   #+END_SRC

** Yasnippet Backtick
   Since the backtick is never used in CC modes, we can use it to expand
   snippets!
   #+BEGIN_SRC emacs-lisp
  (defun my-c-mode-common-hook ()
    (setup-yasnippet-next-key (kbd "`"))
    (setup-yasnippet-next-key (kbd "TAB")))


  (add-hook 'c-mode-common-hook 'my-c-mode-common-hook)
   #+END_SRC

** Irony Mode
   Install =irony= and activate it CC mode.
   #+BEGIN_SRC emacs-lisp
  (use-package irony
      :ensure t)

  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'objc-mode-hook 'irony-mode)

  ;; replace the `completion-at-point' and `complete-symbol' bindings in
  ;; irony-mode's buffers by irony-mode's function
  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))

  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)


  (use-package company-irony-c-headers
      :ensure t)

  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-irony-c-headers))
   #+END_SRC
** RTags
   Install RTags and activate it.
   #+BEGIN_SRC emacs-lisp
  (use-package rtags
      :ensure t
      :init
      (progn
        (setq rtags-completions-enabled t)
        (setq rtags-autostart-diagnostics t))
      :config
      (rtags-enable-standard-keybindings))


  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-rtags))

  (with-eval-after-load 'cc-mode
    (define-key c-mode-base-map (kbd "C-.") #'rtags-find-symbol-at-point)
    (define-key c-mode-base-map (kbd "M-.") #'rtags-find-symbol)
    (define-key c-mode-base-map (kbd "C-,") #'rtags-find-references-at-point)
    (define-key c-mode-base-map (kbd "M-,") #'rtags-find-references)
    (define-key c-mode-base-map (kbd "M-[") #'rtags-location-stack-back)
    (define-key c-mode-base-map (kbd "M-]") #'rtags-location-stack-forward))
   #+END_SRC
** Flycheck
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
         :ensure t)

     (add-hook 'c++-mode-hook 'flycheck-mode)
     (add-hook 'c-mode-hook   'flycheck-mode)

     (use-package flycheck-rtags
     :ensure t)

     (defun my-flycheck-rtags-setup ()
       (flycheck-select-checker 'rtags)
       (setq-local flycheck-highlighting-mode nil)
       (setq-local flycheck-check-syntax-automatically nil))

     (add-hook 'c-mode-common-hook #'my-flycheck-rtags-setup)


     (use-package flycheck-irony
         :ensure t)
     (eval-after-load 'flycheck
       '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
   #+END_SRC
** CMake IDE
   Automatically calling =rdm= if possible.
   #+BEGIN_SRC emacs-lisp :tangle no
  (use-package cmake-ide
      :ensure t
      :config
      (when (executable-find "rdm")
        (cmake-ide-setup)))
   #+END_SRC


* CMake Support
  #+BEGIN_SRC emacs-lisp
  (use-package cmake-mode
      :ensure t)

  (use-package cmake-font-lock
      :ensure t)

  (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
  (add-hook 'cmake-mode-hook 'cmake-font-lock-activate)
  #+END_SRC


* Rust mode
  Rust is the hottest thing on the market right now.
  #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
         :ensure t)
     (add-hook 'rust-mode-hook
               (lambda ()
                 (interactive)
                 (electric-pair-mode 1)))

     (add-hook 'rust-mode-hook #'rustfmt-enable-on-save)
  #+END_SRC


* Undo
  Tree
  Undo tree gives a nice visualization of the undo-state. It makes
  navigating the undo states much more intuitive.
  #+BEGIN_SRC emacs-lisp
  (use-package undo-tree
      :ensure t
      :config
      (progn
        (global-undo-tree-mode)
        (with-eval-after-load 'undo-tree
          (define-key undo-tree-visualizer-mode-map (kbd "M-u") #'undo-tree-visualizer-quit)
          (define-key undo-tree-visualizer-mode-map (kbd "j") #'undo-tree-visualize-redo)
          (define-key undo-tree-visualizer-mode-map (kbd "k") #'undo-tree-visualize-undo)
          (define-key undo-tree-visualizer-mode-map (kbd "h") #'undo-tree-visualize-switch-branch-left)
          (define-key undo-tree-visualizer-mode-map (kbd "l") #'undo-tree-visualize-switch-branch-right)
          )
        )
      :bind
      ("M-u" . undo-tree-visualize))
  #+END_SRC


* Asymptote Mode
  #+BEGIN_SRC emacs-lisp
  (use-package asy-mode
    :load-path "lisp/")
  #+END_SRC


* It's Magit!
  =Magit= is a gerat Git client; it alone makes emacs worth using.
  #+BEGIN_SRC emacs-lisp
  (use-package magit
      :ensure t
      :bind ("C-x g" . magit-status))
  #+END_SRC


* Hakyll Posts
  See [[http://abizern.org/2014/01/05/hakyll-new-post-with-emacs/][this page]] for setting up Hakyll with emacs.
  #+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
      :ensure t)

  (use-package markdown-mode+
      :ensure t)

  (defun hakyll-site-location ()
    "Return the location of the Hakyll files."
    (file-name-as-directory (concat user-dropbox-folder "thoughts-equidistributed")))

  (defun hakyll-new-post (title tags)
    "Create a new Hakyll post for today with TITLE and TAGS."
    (interactive "sTitle: \nsTags: ")
    (let ((file-name (hakyll-post-title title)))
      (set-buffer (get-buffer-create file-name))
      (markdown-mode)
      (insert
       (format "---\ntitle: %s\ntags: %s\ndescription: \n---\n\n" title tags))
      (write-file
       (expand-file-name file-name (concat (hakyll-site-location) "posts")))
      (switch-to-buffer file-name)))

  (defun hakyll-post-title (title)
    "Return a file name based on TITLE for the post."
    (concat
     (format-time-string "%Y-%m-%d")
     "-"
     (replace-regexp-in-string " " "-" (downcase title))
     ".org"))
  #+END_SRC




* Shell mode
  I want to be able to use =C-l= to clear the screen in shell modes, so
  use the following code.
  #+BEGIN_SRC emacs-lisp
  (defun legendre6891/my-clear ()
    (interactive)
    (let ((comint-buffer-maximum-size 0))
      (comint-truncate-buffer)))


  (defun eshell-clear-buffer ()
    "Clear terminal"
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)))

  (add-hook 'eshell-mode-hook
            '(lambda ()
              (local-set-key (kbd "C-l") 'eshell-clear-buffer)
              (company-mode 0)))


  (with-eval-after-load 'ess
    (define-key inferior-ess-mode-map (kbd "C-l") #'legendre6891/my-clear))
  #+END_SRC


* Small Utilities
** Tomatinho
   Seems like a good Pomodoro tracker.
   #+BEGIN_SRC emacs-lisp
  (use-package tomatinho
      :ensure t)
   #+END_SRC

** Rainbow
   #+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
      :ensure t)
   #+END_SRC

** CSV-Mode
   CSV mode is pretty cool for viewing CSV files.
   #+BEGIN_SRC emacs-lisp
  (use-package csv-mode
      :ensure t
      :config
      (progn
        (define-key csv-mode-map (kbd "M-l") #'csv-align-fields)
        (define-key csv-mode-map (kbd "M-L") #'csv-unalign-fields)
        (define-key csv-mode-map (kbd "TAB") #'csv-forward-field)
        (define-key csv-mode-map (kbd "<backtab>") #'csv-backward-field)
        )
      )

   #+END_SRC

** Very Large Files
   Use this mode to view large files.
   #+BEGIN_SRC emacs-lisp
  (use-package vlf
      :ensure t)
   #+END_SRC
** Sublimity
   This is nice eye-candy, but don't enable it by default.
   #+BEGIN_SRC emacs-lisp
  (use-package sublimity
      :ensure t
      :init
      (use-package sublimity-map)
      :config
      (progn
        (sublimity-map-set-delay 0)
        ))
   #+END_SRC

** Silent Package Upgrader
   Upgrade packages silently and automatically. Nope! This breaks too easily.
   #+BEGIN_SRC emacs-lisp :tangle no
(use-package spu
  :ensure t
  :defer 5 ;; defer package loading for 5 second
  :config (spu-package-upgrade-daily))
   #+END_SRC

** Pretty Print
   #+BEGIN_SRC emacs-lisp
    (unless (boundp 'x-max-tooltip-size)
      (setq x-max-tooltip-size '(80 . 40)))

  (use-package pp+
    :ensure t)
   #+END_SRC
** Thing-At-Point
   #+BEGIN_SRC emacs-lisp
     (use-package thingatpt+
         :ensure t)
   #+END_SRC

** Multi Term
   #+BEGIN_SRC emacs-lisp
  (use-package multi-term
      :ensure t)
   #+END_SRC

** Exec-Path-From-Shell
   On Mac OS X (macOS), I want to the path set by my =bashrc= or =zshrc= be
   inherited without launching =emacs= from the shell.
   #+BEGIN_SRC emacs-lisp :tangle no
  (when (memq window-system '(mac ns))
    (use-package exec-path-from-shell
        :ensure t
        :config
        (when (memq window-system '(mac ns))
          (exec-path-from-shell-initialize))))
   #+END_SRC


* Running Recompile
  See [[https://www.emacswiki.org/emacs/CompileCommand#toc10][this link on EmacsWiki]] on how to run =compile= and =recompile=
  in a pleasant way.
  #+BEGIN_SRC emacs-lisp
(defun recompile-quietly ()
  "Re-compile without changing the window configuration."
  (interactive)
  (save-window-excursion
    (recompile)))
  #+END_SRC


* Evil Mode
It's finally time to try out =evil-mode= again.
** Installation
#+BEGIN_SRC emacs-lisp
  (use-package evil
      :ensure t

      :init
      (setq evil-ex-search-vim-style-regexp t
            ;; Need to set this INSIDE CUSTOMIZE!!!!
            evil-search-module 'evil-search
            evil-symbol-word-search t
            evil-want-C-u-scroll t
            evil-want-Y-yank-to-eol t)

      :config
      (evil-mode t)
      (evil-escape-mode))

  (use-package general
      :ensure t)
#+END_SRC

** Evil-escape
#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
      :ensure t
      :init
      (setq-default evil-escape-key-sequence "jk"))
#+END_SRC

** Evil-Mode specific bindings
*** Readline mode bindings
Some Emacs bindings are actually quite nice, so let's setup them
instead of =evil-mode= bindings.
#+BEGIN_SRC emacs-lisp 
  (general-define-key :keymaps 'global
                      :states '(insert emacs visual normal)
                      "C-a" 'move-beginning-of-line
                      "C-e" 'move-end-of-line)
#+END_SRC

*** LaTeX support
To support =LaTeX=, it's better to restore the keybindings we have
before.
#+BEGIN_SRC emacs-lisp 
  (general-define-key :keymaps 'LaTeX-mode-map
                      :states '(normal emacs insert visual)
                      "C-t" 'latex-compile
                      "C-v" 'TeX-view
                      "M-=" 'LaTeX-fill-buffer)

  (general-define-key :keymaps 'plain-TeX-mode-map
                      :states '(normal emacs insert visual)
                      "C-t" 'my-tex-compile
                      "C-v" 'TeX-view)

  (defun legendre/insert-equation ()
    (interactive)
    (unless (texmathp)
      (cdlatex-environment "equation")))

  (defun legendre/insert-and ()
    (interactive)
    (insert "\\quad \\text{and} \\quad"))

  (defun legendre/insert-split ()
    (interactive)
    (if (texmathp)
        (cdlatex-environment "split")
      (progn
        (cdlatex-environment "equation")
        (cdlatex-environment "split"))))

  (defun legendre/reformat-buffer ()
    (interactive)
    (save-excursion
      (indent-region (point-min) (point-max) nil)))

  (general-define-key :keymaps 'LaTeX-mode-map
                      :states '(insert emacs)
                      "M-e" #'legendre/insert-equation
                      "M-s" #'legendre/insert-split
                      "M-a" #'legendre/insert-and)

  (general-define-key :keymaps 'global
                      "M-=" #'legendre/reformat-buffer)
#+END_SRC

** Commenting
   Let's bring over the nice =vim-commentary= package into Emacs.
    #+BEGIN_SRC emacs-lisp
      (use-package evil-commentary
        :ensure t
        :init
        (progn
          (evil-commentary-mode)))
    #+END_SRC

** Other bindings
#+BEGIN_SRC emacs-lisp 
  (general-define-key :keymaps 'global
                      :states '(normal insert)
                      "C-b" #'ivy-switch-buffer)
#+END_SRC
** Visual Star
#+BEGIN_SRC emacs-lisp 
  (use-package evil-visualstar
           :ensure t
           :config
           (global-evil-visualstar-mode t))
#+END_SRC


* Epilog
  Packages to investigate
  - [[https://github.com/mrkkrp/zzz-to-char][=zzz-char=]]
  - =char-menu=
  - =latex-unicode-math-mode=
  - [[https://github.com/noctuid/general.el][=general=]] for keybindings.



  Some Org mode related settings to to faciliate editting of this file.

  #+PROPERTY: header-args:emacs-lisp :tangle yes

  #+LATEX_HEADER: \usepackage{tgtermes}
  #+LATEX_HEADER: \usepackage{inconsolata}
  #+LATEX_HEADER: \def\textlambda{$\lambda$}
  #+LATEX_HEADER: \def\textxi{$\xi$}

